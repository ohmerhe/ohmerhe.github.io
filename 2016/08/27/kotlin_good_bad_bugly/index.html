<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>Kotlin：The Good, The Bad, and The Ugly(译) | Ohmer&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="tags: Kotlin, Android
在我的 上一篇文章, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。
The GoodKotlin 有许多让人喜欢的理由。像 null safety、property access 和 unchecked exceptions 类似这些明显的特性在">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin：The Good, The Bad, and The Ugly(译)">
<meta property="og:url" content="http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/index.html">
<meta property="og:site_name" content="Ohmer's Blog">
<meta property="og:description" content="tags: Kotlin, Android
在我的 上一篇文章, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。
The GoodKotlin 有许多让人喜欢的理由。像 null safety、property access 和 unchecked exceptions 类似这些明显的特性在">
<meta property="og:image" content="http://7xpox6.com1.z0.glb.clouddn.com/image/stock-photo-160635495.jpg?imageView2/1/w/200">
<meta property="og:updated_time" content="2016-08-27T09:00:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin：The Good, The Bad, and The Ugly(译)">
<meta name="twitter:description" content="tags: Kotlin, Android
在我的 上一篇文章, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。
The GoodKotlin 有许多让人喜欢的理由。像 null safety、property access 和 unchecked exceptions 类似这些明显的特性在">
<meta name="twitter:image" content="http://7xpox6.com1.z0.glb.clouddn.com/image/stock-photo-160635495.jpg?imageView2/1/w/200">

    

    
        <link rel="icon" href="/css/images/favicon.png" />
    

    <link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/vendor/open-sans/styles.css">
    <link rel="stylesheet" href="/vendor/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/vendor/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/vendor/fancybox/jquery.fancybox.css">
    
    
    
    

</head>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Ohmer&#39;s Blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.jpg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="http://ohmerhe.com"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://ohmerhe.com"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                
<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png" />
            <h2 id="name">Ohmer</h2>
            <h3 id="title">Android Developer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>ShangHai, China</span>
            <a id="follow" target="_blank" href="https://github.com/ppoffice/">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                18
                <span>posts</span>
            </div>
            <div class="article-info-block">
                13
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    <td><a href="http://github.com/ohmerhe/" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
                    
                    <td><a href="https://twitter.com/ohmerhe/" target="_blank" title="twitter"><i class="fa fa-twitter"></i></a></td>
                    
                    <td><a href="/atom.xml" target="_blank" title="rss"><i class="fa fa-rss"></i></a></td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-kotlin_good_bad_bugly" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            
	
		<img src="http://7xpox6.com1.z0.glb.clouddn.com/image/stock-photo-160635495.jpg?imageView2/1/w/1024/h/460" class="article-banner" />
	



        
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            Kotlin：The Good, The Bad, and The Ugly(译)
        </h1>
    

                <div class="article-meta">
                    
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2016/08/27/kotlin_good_bad_bugly/">
            <time datetime="2016-08-27T08:59:00.000Z" itemprop="datePublished">2016-08-27</time>
        </a>
    </div>


                    
                    
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Android/">Android</a>, <a class="tag-link" href="/tags/Kotlin/">Kotlin</a>
    </div>

                </div>
            </header>
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>tags: Kotlin, Android</p>
<p>在我的 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="external">上一篇文章</a>, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。</p>
<h2 id="The-Good"><a href="#The-Good" class="headerlink" title="The Good"></a>The Good</h2><p>Kotlin 有许多让人喜欢的理由。像 <code>null safety</code>、<code>property access</code> 和 <code>unchecked exceptions</code> 类似这些明显的特性在 <a href="https://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/" target="_blank" rel="external">publications</a> 都有描述，我就不重复了。我只讲一些我真正喜欢但很少被提到的特性。</p>
<h3 id="Automatic-conversion-of-Java-to-Kotlin"><a href="#Automatic-conversion-of-Java-to-Kotlin" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>JetBrains 在 IntelliJ 中集成了 <code>Java to Kotlin converter</code> 为我们节约了大量的时间。虽然它还不是很完美，但是它让你不用再重复输入。要是没有它，你将要花费大量的时间从 Java 代码转换成 Kotlin。</p>
<h3 id="lateinit-Delegates-notNull-and-lazy"><a href="#lateinit-Delegates-notNull-and-lazy" class="headerlink" title="lateinit, Delegates.notNull and lazy"></a>lateinit, Delegates.notNull and lazy</h3><p>Kotlin 的 <code>null safety</code> 非常好，但是由于在 Android 的 Activity 生命周期的设计，你常常不得不在 <em>onCreate</em> 这样的回调中初始化一个变量，而不是在类的构造函数中。假设你有一个属性需要定义，你肯定想要这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val name: String</div></pre></td></tr></table></figure>
<p>如果你必须在 <code>onCreate</code> 中初始化这个属性，就不能用 <code>val</code> 定义，而必须使用 <code>var</code>。但是这样你必须在定义的时候为该属性提供一个值进行初始化，或者将它定义为可空类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name: String? = null</div></pre></td></tr></table></figure>
<p>这样的确有效，但是当你每次使用它的时候都要进行空检查。虽然 Korlin 提供了友好的的空断言，但是在实践中即使你知道你的属性不会为空，你也不愿意到处使用 <code>!!</code>。庆幸的是，Kotlin 提供了更好的方式：<a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties" target="_blank" rel="external"><em>lateinit</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="external"><em>Delegates.notNull</em></a>。任何一个都能可以让你在不初始化的情况下定义一个非空类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lateinit var name: String</div><div class="line">var age: Int by Delegates.notNull&lt;Int&gt;()</div></pre></td></tr></table></figure>
<p>这两种方式中，当你尝试在初始化之前访问该属性都会抛出异常。除了<code>lateinit</code> 不能用于基础类型的定义，这两种方法没有什么大的差别。</p>
<p>你还有第三种选择就是使用 <code>lazy</code> 委托。如果一个属性能够利用其他属性或方法获得数据进行初始化，那么 <code>lazy</code> 会是一个很好的选择。类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val imm: InputMethodManager by lazy &#123; </div><div class="line">    getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面块里面的代码在第一次读取之前并不会执行，执行的结果会被保存起来以供后面使用，所以后面的代码块只会被执行一次。</p>
<h3 id="Functional-collection-extensions"><a href="#Functional-collection-extensions" class="headerlink" title="Functional collection extensions"></a>Functional collection extensions</h3><p>Kotlin 提供为集合和迭代类提供了大量的函数式 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions" target="_blank" rel="external">扩展方法</a>。像 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html" target="_blank" rel="external"><em>any</em></a>、 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="external"><em>joinToString</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html" target="_blank" rel="external"><em>associate</em></a> 的方法能够帮助节约大量的时间，不用像 Java 里面一样手工编写 <em>for</em> 循环去实现。</p>
<p>Kotlin 还提供了大量的函数式集合操作的懒加载模式，在这种模式下载每个操作执行之前并不会进行集合的拷贝，但是在我的接受范围内，发现懒加载和即刻加载在性能上并没有什么大的差别。</p>
<h3 id="Named-and-default-function-arguments"><a href="#Named-and-default-function-arguments" class="headerlink" title="Named and default function arguments"></a>Named and default function arguments</h3><p><a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">命名参数</a> 和 <a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="external">默认参数</a> 是非常基础的，但它们让你不再需要重载方法，并且也替代了 Builder 模式的一种使用场景。</p>
<p>根据具体使用场景，你甚至可以在依赖注入中将生产依赖作为默认参数，然后在测试的时候传入模拟的数据。</p>
<p>例如，你在 <code>presenter</code> 中需要一些全局状态，你可以这样定义构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Presenter(</div><div class="line">        val okhttp: OkHttp = productionOkHttp(),</div><div class="line">        val picasso: Picasso = productionPicassoInstance()</div><div class="line">) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>这样，你就你可以 <code>UI</code> 代码中创建 <code>presenter</code> 实例的时候不传递任何参数，但是在测试的时候可以传递模拟的实例作为参数。完整的依赖注入框架会更加强大，但这是一个一些简单语言构造的很好的例子。</p>
<h2 id="The-Bad"><a href="#The-Bad" class="headerlink" title="The Bad"></a>The Bad</h2><p>尽管 Kotlin 非常棒，但是它并不完美。我列举了一下我不喜欢的部分。</p>
<h3 id="No-namespaces"><a href="#No-namespaces" class="headerlink" title="No namespaces"></a>No namespaces</h3><p>Kotlin 允许你在文件中定义顶级的函数和属性。这是一个非常棒的特性，但是这会带来所有从 Kotlin 引用的顶级声明无法区分的困扰。有时，这让我们在读代码的时候很难快速确定用的是哪一个函数。</p>
<p>例如，你定义这样一个顶级函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun foo() &#123;...&#125;</div></pre></td></tr></table></figure>
<p>你可以通过 <code>foo()</code> 调用。如果你在不同的包里面也存在同样的方法，在调用侧不能明显区分出是调用的哪个方法。你可以通过在前面添加包名的方式去调用，但是如果 Java 约定的包名很深，似乎不太好。</p>
<p>一种近似的解决方案是使用单例的 <code>object</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object FooActions &#123;</div><div class="line">    fun foo() &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样你在 Kotlin 中可以通过 <code>FooActions.foo()</code> 调用，但是在 Java 代码中就不是那么友好了。在 Java 中你必须要这样 <code>FooActions.INSTANCE.foo()</code> 这样调用，这看起来并不完美。你可以使用 <code>@JvmStatic</code> 去注解你的方法从而省掉 <code>INSTANCE</code>，这是你能做到的最好结果。这并不是什么大不了的事，但是如果 Kotlin 能够提供命名空间的话，能省不少事。</p>
<h3 id="No-static-modifier"><a href="#No-static-modifier" class="headerlink" title="No static modifier"></a>No static modifier</h3><p>无独有偶，Kotlin 提供为静态函数和属性提供了一个和 Java 不一样的处理方式。并不是说有多烂，只是觉得让代码变得不干净而且没有必要。例如，在 Android 的 <code>View</code> 类中定义的静态属性 <code>View.VISIBLE</code> 和静态函数 <code>View.inflate</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class View &#123;</div><div class="line">    public static final int VISIBLE = 0x00000000;</div><div class="line">    public static final int INVISIBLE = 0x00000004;</div><div class="line">    public static View inflate(Context context, int resource) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个定义是简单的。然而，在 Kotlin 代码中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class View &#123;</div><div class="line">    companion object &#123;</div><div class="line">        @JvmField </div><div class="line">        val VISIBLE: Int = 0x00000000</div><div class="line">        @JvmField </div><div class="line">        val INVISIBLE: Int = 0x00000004</div><div class="line">        @JvmStatic</div><div class="line">        fun inflate(context: Context, resource: Int) &#123;...&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管 Kotlin 的版本并没有那么恐怖，但是它的复杂程度超过了我对这门语言的预期。如果把注解去掉，那么你在 Java 代码中不得不使用这样可怕的语法去调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// With annotations:</div><div class="line">View.VISIBLE;</div><div class="line">//Without annotations:</div><div class="line">View.Companion.getVISIBLE();</div></pre></td></tr></table></figure>
<p>没有更好的方式去创建静态函数和属性让我感觉很奇怪。我知道 <code>companion objects</code> 是真正的对象并且能够用来实现接口，但是这并不能足够说明能完全替代普通的静态声明。</p>
<h3 id="Automatic-conversion-of-Java-to-Kotlin-1"><a href="#Automatic-conversion-of-Java-to-Kotlin-1" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>在我的第一篇帖子里这是我列出来的我喜欢 Kotlin 的愿意之一，并且它很好用。但是正由于它在 80% 的时候都运行的很好，它在一些场景的失败实在令人沮丧。</p>
<p>Java 文档经常错位，特别是在段落横跨了好几行的时候。静态域和方法被转换成 <code>companion object</code>，除非你手动添加为他们分别添加 <code>@JvmField</code> 和 <code>@JvmStatic</code> ，你之前 Java 调用代码不在有效而出错。</p>
<p>由于 Kotlin 团队花了大量的时间在转换代码上，我相信这些问题一定会被修复的，因此我对这些问题保持乐观。</p>
<h3 id="Required-property-accessor-syntax"><a href="#Required-property-accessor-syntax" class="headerlink" title="Required property accessor syntax"></a>Required property accessor syntax</h3><p>Kotlin 提供一个很棒的语法糖叫做「属性访问语法」，它让你可以像访问 Kotlin 属性一样访问 <code>JavaBeans</code> 类型的 <code>getters</code> 和 <code>setters</code> 方法。例如，你可以这样 <code>activity.context</code> 调用 <code>Activity.getContext()</code>，而不用写整个方法名。如果你在 Kotlin 使用传统的方式调用，lint 会给你一个警告告诉你使用「属性调用语法」。</p>
<p>这是一个很好的特性，但是有时候我的方法名以 <code>get</code> 开始，但是并不想使用「属性调用语法」。一个很常见的例子就是 Java 的原子类。如果你有一个变量 <code>val i = AtomicInteger()</code>，你可能想通过 <code>i.getAndIncrement()</code> 调用。但是 Kotlin 会想让你用 <code>i.andIncrement</code> 这种方式调用。这明显是画蛇添足。</p>
<p>你可以在每个调用的地方加上 <code>@Suppress(“UsePropertyAccessSyntax”)</code>，但很丑。如果你可以为这个函数添加一个注解告诉 linter 不要把它当做一个属性会更好。</p>
<h3 id="Method-count"><a href="#Method-count" class="headerlink" title="Method count"></a>Method count</h3><p>用 Kotlin 写代码肯定会减少你项目中的代码行数。但是它也会提高你的代码在编译以后的方法数。有很多原因导致这一点，但是其中一个主要原因就是 Kotlin 属性的实现方式。</p>
<p>和 Java 不一样，Kotlin 没有提供单独定义域的方式。你必须使用 <code>val</code> 或者 <code>var</code> 来声明变量。这样有一个好处，就是你可以随意为一个属性添加 <code>get</code> 或 <code>set</code> 方法而不会破坏其他地方对该属性引用的代码。这个特性省去了像 Java 一样定义 <code>getters</code> 和 <code>setters</code> 方法。</p>
<p>尽管如此，这个特性需要一定的成本。每一个公开的 <code>val</code> 变量都会导致 Kotlin 生成一个「支持域」和一个能被 Java 调用的 <code>getter</code> 方法。每一个公开的 <code>var</code> 变量都会生成 <code>getter</code> 和 <code>setter</code> 方法。庆幸的是，私有属性的 <code>getters</code> 和 <code>setters</code> 会生成域而不是生成方法。如果你之前的 Java 代码中定义了大量的公开域（这在定义常量的时候很常见），你会惊奇的发现方法大幅上升。</p>
<p>如果你的 Android 应用快接近方法数限制了，我建议你为不需要自定义 <code>getter</code> 方法的常量加上 <code>@JvmField</code> 注解。这样会阻止  <code>getters</code> 方法的生成，从而减少你的方法数。「更新：Kirill Rakhman 在评论中指出，你可以使用 <code>const</code> 修饰符替代 </p>
<p>不过其实没有那么糟。就像我在 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="external">converting an app to 100% Kotlin</a> 文章里讨论过的，Kotlin 的标准库非常小，并且能够替代 Java 的许多常用库，这些库通常都更大，现在你再也不需要他们了。多亏了 Kotlin 的标准库，在从 Java 全部转换到 Kotlin 以后方法数反而减少了。只要你控制不会出现大范围的方法数提升，就不会有什么问题。</p>
<h2 id="The-Ugly"><a href="#The-Ugly" class="headerlink" title="The Ugly"></a>The Ugly</h2><p>最后，Kotlin 有两个设计我不是很认同，而且我不期望这个在未来会有什么改变。</p>
<h3 id="SAM-conversion-and-Unit-returning-lambdas"><a href="#SAM-conversion-and-Unit-returning-lambdas" class="headerlink" title="SAM conversion and Unit returning lambdas"></a>SAM conversion and Unit returning lambdas</h3><p>这真是一个莫名其妙的设计。</p>
<p>可以嵌入 lambda 表达式是 Kotlin 最好的特性之一。如果有一个 Java 函数，它只有一个 SAM 接口（只有一个抽象方法的接口）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void registerCallback(View.OnClickListener r)</div></pre></td></tr></table></figure>
<p>无论是 Java 还是 Kotlin，你都可以传递一个普通的 lambda 表达式去调用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">registerCallback(() -&gt; &#123; /** do stuff */ &#125;)</div><div class="line">//Kotlin</div><div class="line">registerCallback &#123; /** do stuff */ &#125;</div></pre></td></tr></table></figure>
<p>这的确很棒。但当你尝试去用 Kotlin 去定义类似的方法是莫名的困难。从 Java 测调用没有什么不同，但是当从 Kotlin 调用时需要明确指定类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun registerCallback(r: View.OnClickListener)</div><div class="line">// Kotlin. Note that parenthesis are required now.</div><div class="line">registerCallback(View.OnClickListener &#123; /** do stuff */ &#125;)</div></pre></td></tr></table></figure>
<p>不得不说这很烦人，特别是当你从 Java 代码转换到 Kotlin 从而导致 Kotlin 代码不能再正常运行的时候。</p>
<p>常见的方式是用函数类型定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun registerCallback(r: () -&gt; Unit)</div></pre></td></tr></table></figure>
<p> 这样用 Kotlin 调用起来会很方便，但是由于所有的 Kotlin 函数都需要一个返回值，这导致用 Java 调用该函数的时候变得很糟。你不得不显式地从 Java 表达式返回 <code>Unit</code>，这导致 lambda 表达式不可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> registerCallback(() -&gt; &#123;</div><div class="line">    /** do stuff */</div><div class="line">    return Unit.INSTANCE;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如果你在用 Kotlin 写库的话，根本找不到一个好的方式去实现一个高阶函数同时让 Java 和 Kotlin 都能方便的调用。在我的 <a href="https://github.com/ajalt/flexadapter" target="_blank" rel="external">FlexAdapter</a> 库里面，我尝试为为每个方法重载 <code>SAM interface</code> 或者 Kotlin 函数类型的参数。这样无论用这两种的哪种语言调用都很方便，但是库的 API 变得不简洁。</p>
<p>希望 Kotlin 的设计者们能够改变他们的想法在将来允许 <code>SAM</code> 转化成 Kotlin 的函数定义，但是我并不抱什么希望。</p>
<h3 id="Closed-by-default"><a href="#Closed-by-default" class="headerlink" title="Closed by default"></a>Closed by default</h3><p>到目前为止我说的所有关于 Kotlin 的缺点基本都是小的语法细节上的不简洁，并不是什么大事。但是，有一个设计在将来有可能导致巨大的痛苦：所有的类和方法默认都是封闭的。这种做法是被 <code>Effective Java</code> 里所推崇的，理论上听起来也很有道理，但对于任何一个需要使用一个有缺陷的第三方库的人来说都是一个坏的选择。</p>
<blockquote>
<p>把所有的叶类都设置成静态的。毕竟你在完成这样一个项目——没有人能够通过扩展你的类的方式来完善你的工作成果。或许是由于安全原因——毕竟，<code>java.lang.String</code> 是 <code>final</code> 不就是由于这个原因吗？如果你项目的其他的成员向你抱怨，就告诉他们这样能提高执行效率——<a href="http://www.mindprod.com/jgloss/unmaindesign.html" target="_blank" rel="external"><em>Roedy Green, How to Write Unmaintainable Code</em></a></p>
</blockquote>
<p>Kotlin 的文档里面的确有文章尝试去抵制这一决定，所以我把他们说的三个理由列出来。</p>
<h3 id="“Best-practices-say-that-you-should-not-allow-these-hacks-anyway”"><a href="#“Best-practices-say-that-you-should-not-allow-these-hacks-anyway”" class="headerlink" title="“Best practices say that you should not allow these hacks anyway”"></a>“Best practices say that you should not allow these hacks anyway”</h3><p>关于对继承封闭的论据基本是围绕「Fragile Base Class Problem」展开，它认为如果允许在你的库的基础上继承出子类，他们可能改变代码运行的方式从而导致一些 bug。然而这只是一种可能性，会导致库运行异常从而导致 bug 的方式实在太多了。如果你重写一个类的功能，很明显你应该为破坏代码的运行负责。</p>
<p>我之所以用「很明显」是因为重写一个库的功能是很明确的该有使用方自己负责。我已经辅导计算机科学学生很多年了，他们会范所有你能想象到的错误，但是他们从不会因为重载一个方法导致的破坏感到奇怪。实在有太多不经意的方式会导致对依赖库使用的破坏，例如你传递的参数类型是对的但单位却传错了，或者你忘了调用一个必须调用的方法。</p>
<p>我欣赏那种减少代码被破坏可能性的编码方式，把类设置成不可变的的确能达到效果。但可以确定的是所有依赖库一定不是完整的或者是存在缺陷的，你又不可避免的要使用这些依赖库。为了修改一个封闭类，人们常常会使用一些 hack 的方法，这经常会仅仅是重写一两个类或者方法带来的 bug 更多。如果你不相信我说的话，这里有一个活生生的例子，如果你是一个 Android 开发者的话，你应该印象深刻：</p>
<p>AppCompat 23.2.0 终于把 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="external">VectorDrawables</a> 加到 support 包里了。由于可以帮助减少 APK 的体积和内存的占用，要不是它有一个 bug <a href="https://code.google.com/p/android/issues/detail?id=205236" target="_blank" rel="external">会导致在 Activity 里面导致内存泄露</a><br>，本应该收到广泛欢迎。这个支持包在 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="external">几周后被移除</a>。</p>
<p>内存泄露是怎么导致的呢？为了 <a href="https://medium.com/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88" target="_blank" rel="external">提高 VectorDrawable 填充性能</a>，这个支持包的作者们需要改进 <code>Context.getDrawable</code> 的实现。但是这个方法是不可变的（final），所以他们不得不为每一个视图创建一份 <code>Resources wrapper</code> 的拷贝来处理 <em>VectorDrawables</em>。且不说这带来了大量的工作，这也导致大量的 <code>wrapped Resources</code> 变得不同步和为了复制产生的大量内存开销。如果那个方法不是不可变的，他们就不会这样胡搞了。</p>
<h3 id="“People-successfully-use-other-languages-C-C-that-have-similar-approach”"><a href="#“People-successfully-use-other-languages-C-C-that-have-similar-approach”" class="headerlink" title="“People successfully use other languages (C++, C#) that have similar approach”"></a>“People successfully use other languages (C++, C#) that have similar approach”</h3><p>人们在 Python 这样的语言可以在任何时候做任何修改。Python 也有像 <code>_asdict</code> 这样「非公有」不会在文档里描述的方法。它也有像 <code>__intern</code> 这样的 <a href="https://zh.wikipedia.org/wiki/Visual_C%2B%2B%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" target="_blank" rel="external">name mangled</a> 的函数，很难被发现。你可以自由的用 monkey-patch 或者重写任何一个你想重写的方法，Python 并不禁止这样做。</p>
<p>在我五年全职开发 Python 的期间，我从没有想过谁会通过重写方法破坏我的代码。我能想象在大多数情况下，用正确安全的方法去改变一个私有方法比由于 Python 的禁止而不得不重新实现一个同样的功能更加节约时间。</p>
<p>我并不是说要盲目地把每个类的实现都要改一遍，但是没有理由当我想这么做的时候却做不了。在 Python 社区里面有一句俗语 “We’re all consenting adults here”。你想对我的类做任何修改都可以。</p>
<h3 id="“If-people-really-want-to-hack-there-still-are-ways-you-can-always-write-your-hack-in-Java-and-call-it-from-Kotlin-see-Java-Interop-and-Aspect-frameworks-always-work-for-these-purposes”"><a href="#“If-people-really-want-to-hack-there-still-are-ways-you-can-always-write-your-hack-in-Java-and-call-it-from-Kotlin-see-Java-Interop-and-Aspect-frameworks-always-work-for-these-purposes”" class="headerlink" title="“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”"></a>“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”</h3><p>这真是一个荒诞的论点。即使是用 Java 如果你不用很难令人接受的反射的话，你依然不能重写封闭的 Kotlin 函数，所以这个论调无足轻重。</p>
<p>不能对依赖库进行扩展意味着想要添加任何新的特性和修改 bug 都很难。现实中，大多数库都需要使用一些黑客的手段。这就是现实，而且不会改变。任何库的作者都不能预测所有用户可能碰到的场景。所有的类都是不可变的只能让库的使用者实现库本身没有的功能的时候变得更加困难。相对于 Kotlin 其他语言特性的便利性，这个设计实在是太令人费解了。</p>
<p>如果你在编写一个 Kotlin 的依赖库，请把你所有的公开方法都设置成开放的。这会让你的用户更加方便。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Kotlin 是一门非常棒的语言。它比 Java 简洁多了，它还有一个非常优秀的标准库，有了这个标准库你就可以将大量为了维持 Java 勉强可用下去的库都删掉了。多亏了代码自动转换功能，你可以很方便的把 Java 代码转换成 Koltin 代码，并且这个功能会越来越完善。如果你是一名 Android 开发者，你真应该去试一试。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>[1]</strong> In the case of a <em>lateinit </em>property,<em>kotlin.UninitializedPropertyAccessException </em>will be thrown, where the<em>Delegates.notNull </em>will throw an <em>IllegalStateException</em>.</li>
<li><strong>[2]</strong> There are some details about <em>lateinit </em>that are worth noting, especially if you plan on accessing a <em>lateinit </em>property from Java code. First is that <em>lateinit</em>cannot be applied to primitive types such as <em>Int </em>or <em>Double</em>. The second is that a <em>lateinit </em>property is backed by a field with the same visibility as the property, and this field is visible from Java. Additionally, that backing field can be freely set to null from Java. If any of those are issues for your use case, <em>Delegates.notNull </em>may be a better choice.</li>
<li><strong>[3]</strong> The lazy <em>Sequence </em>operators can outperform the eager versions by up to 20%, but only once list sizes start growing very large. For lists under a megabyte or so in size, the lazy versions often perform the same or worse than the eager versions.</li>
<li><strong>[4]</strong> This is a bit of a simplification. Kotlin will only generate a backing field if you don’t define a get function, or if the defined get function doesn’t reference the implicit<em> field </em>identifier.</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">

    <div class="jiathis_style">
    <span class="jiathis_txt">分享到：</span>
    <a class="jiathis_button_qzone">QQ空间</a>
    <a class="jiathis_button_tsina">新浪微博</a>
    <a class="jiathis_button_tqq">腾讯微博</a>
    <a class="jiathis_button_weixin">微信</a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
    <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<style>
    .jiathis_style div:first-child:not(.jiadiv_01) {
        width: auto !important;
        border: none !important;
    }
    .jiathis_style .jiadiv_01 {
        margin: 10px 0;
        border-radius: 4px;
        border: #e1e1e1 solid 1px;
    }
    .jiathis_style .jiadiv_01 div:first-child {
        display: none;
    }
    .jiathis_style .jiadiv_02 {
        padding: 7px 0 !important;
    }
    .jiathis_style .jiadiv_02 .jiatitle {
        width: 85px;
        border: none;
        height: auto;
        margin: 3px 10px;
        padding: 6px 10px;
        border-radius: 4px;
    }
    .jiathis_style .jiadiv_02 .jiatitle:hover {
        border: none;
    }
    .jiathis_style .jiadiv_02 .jiatitle:nth-child(even) {
        margin-left: 0;
    }
    .jiathis_style .jtico:hover {
        opacity: 1;
    }
    .jiathis_style .ckepopBottom,
    .jiathis_style .centerBottom {
        width: auto !important;
        padding: 5px;
        background: #f7f7f7;
    }
</style>



</div>

            
    
        <a href="http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/#comments" class="article-comment-link disqus-comment-count" data-disqus-url="http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/">Comments</a>
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
    
        <a href="/2016/08/02/kotlin_one_method_no_viewholder/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">Kotlin 一个扩展函数，从此丢掉 ViewHolder</div>
        </a>
    
</nav>


    
</article>


    
    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>

</section>
            
                <aside id="sidebar">
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">recents</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2016/08/27/kotlin_good_bad_bugly/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xpox6.com1.z0.glb.clouddn.com/image/stock-photo-160635495.jpg?imageView2/1/w/200)" alt="Kotlin：The Good, The Bad, and The Ugly(译)" class="thumbnail-image"></span>
    
</a>
                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/08/27/kotlin_good_bad_bugly/" class="title">Kotlin：The Good, The Bad, and The Ugly(译)</a></p>
                            <p class="item-date"><time datetime="2016-08-27T08:59:00.000Z" itemprop="datePublished">2016-08-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2016/08/02/kotlin_one_method_no_viewholder/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xpox6.com1.z0.glb.clouddn.com/image/stock-photo-160624845.jpg?imageView2/1/w/200)" alt="Kotlin 一个扩展函数，从此丢掉 ViewHolder" class="thumbnail-image"></span>
    
</a>
                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/08/02/kotlin_one_method_no_viewholder/" class="title">Kotlin 一个扩展函数，从此丢掉 ViewHolder</a></p>
                            <p class="item-date"><time datetime="2016-08-02T15:57:49.000Z" itemprop="datePublished">2016-08-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2016/07/14/kotlin-type-option/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xpox6.com1.z0.glb.clouddn.com/image/stock-photo-138093189.jpg?imageView2/1/w/200)" alt="NullPointException 利器 Kotlin 可选型" class="thumbnail-image"></span>
    
</a>
                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/07/14/kotlin-type-option/" class="title">NullPointException 利器 Kotlin 可选型</a></p>
                            <p class="item-date"><time datetime="2016-07-14T10:52:57.000Z" itemprop="datePublished">2016-07-14</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2016/07/05/kotlin_function_three_common_methods/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xpox6.com1.z0.glb.clouddn.com/image/stock-photo-160627353.jpg?imageView2/1/w/200)" alt="Kotlin 函数式编程三板斧" class="thumbnail-image"></span>
    
</a>
                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/07/05/kotlin_function_three_common_methods/" class="title">Kotlin 函数式编程三板斧</a></p>
                            <p class="item-date"><time datetime="2016-07-05T14:06:41.000Z" itemprop="datePublished">2016-07-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2016/06/26/loopback_useage_record/" class="thumbnail">
    
    
        <span style="background-image:url(http://7xpox6.com1.z0.glb.clouddn.com/image/stock-photo-153854891.jpg?imageView2/1/w/200)" alt="LoopBack 操作记录" class="thumbnail-image"></span>
    
</a>
                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2016/06/26/loopback_useage_record/" class="title">LoopBack 操作记录</a></p>
                            <p class="item-date"><time datetime="2016-06-26T11:02:04.000Z" itemprop="datePublished">2016-06-26</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/Android/" style="font-size: 17.5px;">Android</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Kotlin/" style="font-size: 20px;">Kotlin</a> <a href="/tags/LoopBack/" style="font-size: 10px;">LoopBack</a> <a href="/tags/MySQL/" style="font-size: 12.5px;">MySQL</a> <a href="/tags/NGINX/" style="font-size: 10px;">NGINX</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/PHP/" style="font-size: 10px;">PHP</a> <a href="/tags/内存泄露/" style="font-size: 10px;">内存泄露</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/树莓派/" style="font-size: 15px;">树莓派</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/网络请求/" style="font-size: 10px;">网络请求</a>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LoopBack/">LoopBack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NGINX/">NGINX</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存泄露/">内存泄露</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树莓派/">树莓派</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泛型/">泛型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络请求/">网络请求</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://kotlinthree.github.io/">KotlinThree</a>
                    </li>
                
                    <li>
                        <a href="http://blog.lanvige.com/">Lanvige&#39;s Zen Garden</a>
                    </li>
                
                    <li>
                        <a href="http://liuduo.me/">刘铎.Me</a>
                    </li>
                
                    <li>
                        <a href="http://blog.mwlio.com/">mwlIO</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-chevron-up"></div>
</aside>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2016 Ohmer<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        
    
    <script>
    var disqus_shortname = 'ohmersblog';
    
    
    var disqus_url = 'http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>



    
        <script src="/vendor/fancybox/jquery.fancybox.pack.js"></script>
    


<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>