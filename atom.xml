<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ohmer&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/3c34286321ffaede601199384e3458c1</icon>
  <subtitle>Code is used to implement idea and impove efficiency</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ohmerhe.com/"/>
  <updated>2019-01-02T02:38:27.119Z</updated>
  <id>http://ohmerhe.com/</id>
  
  <author>
    <name>Ohmer</name>
    <email>ohmerhe@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 Linux 到 Android 线程调度</title>
    <link href="http://ohmerhe.com/2018/03/21/android_thread_scheduling/"/>
    <id>http://ohmerhe.com/2018/03/21/android_thread_scheduling/</id>
    <published>2018-03-21T15:18:07.000Z</published>
    <updated>2019-01-02T02:38:27.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近我们的 APM 上线了应用卡顿的性能检测，我们使用的是和 BlockCanary 同样的方案，通过 Looper Printer 去监控应用的卡顿。在收集到线上数据以后，发现一个比较怪异的现象，大量的卡顿的情况下，当前执行线程（主线程）的执行时间其实并不长，主线程只执行了几毫秒，但是却卡顿1s甚至更长的时间。很明显这个时候是由于主线程没有抢占到CPU导致，为了搞清楚为什么主线程没有抢到CPU，我把 Android 线程调度仔细撸了一遍。</p><h2 id="Linux-进程与Android-线程"><a href="#Linux-进程与Android-线程" class="headerlink" title="Linux 进程与Android 线程"></a>Linux 进程与Android 线程</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>进程是资源管理的最小单位，线程是程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。</p><p>无论按照怎样的分法，一个进程至少需要一个线程作为它的指令执行体，进程管理着资源（比如cpu、内存、文件等等），而将线程分配到某个cpu上执行。一个进程当然可以拥有多个线程，此时，如果进程运行在SMP机器上，它就可以同时使用多个cpu来执行各个线程，达到最大程度的并行，以提高效率；同时，即使是在单cpu的机器上，采用多线程模型来设计程序，正如当年采用多进程模型代替单进程模型一样，使设计更简洁、功能更完备，程序的执行效率也更高，例如采用多个线程响应多个输入，而此时多线程模型所实现的功能实际上也可以用多进程模型来实现，而与后者相比，线程的上下文切换开销就比进程要小多了，从语义上来说，同时响应多个输入这样的功能，实际上就是共享了除cpu以外的所有资源的。</p><p>针对线程模型的两大意义，分别开发出了核心级线程和用户级线程两种线程模型，分类的标准主要是线程的调度者在核内还是在核外。前者更利于并发使用多处理器的资源，而后者则更多考虑的是上下文切换开销。</p><h3 id="内核线程与用户线程"><a href="#内核线程与用户线程" class="headerlink" title="内核线程与用户线程"></a>内核线程与用户线程</h3><p>需要理解 Linux 进程与 Android 线程的关系，需要先解释清楚 Linux 中内核线程、用户线程的关系，在 <a href="http://blog.csdn.net/ylyuanlu/article/details/8830374" target="_blank" rel="noopener">内核线程、轻量级进程、用户线程的区别和联系</a> 中有比较清晰的阐述。可以总结为几点:</p><ul><li>内核线程只运行在内核态，不受用户态上下文的拖累。</li><li>用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全由库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。</li><li>轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。</li><li>LinuxThreads 是用户空间的线程库，所采用的是线程-进程 1对1 模型(即一个用户线程对应一个轻量级进程，而一个轻量级进程对应一个特定 的内核线程)，将线程的调度等同于进程的调度，调度交由内核完成，而线程的创建、同步、销毁由核外线程库完成（LinuxThtreads已绑定到 GLIBC中发行）。</li></ul><blockquote><p>PS: Linux 在2.6之前使用的是 LinuxThreads 线程库,2.6之后是NPTL(Native Posix Thread Library)，NPTL 使用的也是1对1的结构，但是在信号处理，线程同步，存储管理等多方面进行了优化。</p></blockquote><p>此外，Linux 内核不存在真正意义上的线程。Linux 将所有的执行实体都称之为任务（task），每一个任务在 Linux 上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。但是，Linux 下不同任务之间可以选择公用内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，而这些任务就成为这个进程里面的线程。</p><p>比如在 Android 上我们通过 <code>adb shell</code>进入手机后，可以通过 <code>ps</code> 命令查看某个应用下的所有线程，先通过 <code>ps | grep $包名</code>找到对应进程的进程号，然后执行 <code>ps -t -p -P 6493</code>：</p><p><img src="http://images.notend.cn/WX20180314-172734.png" alt=""></p><p>同时我们可以，执行 <code>ls /proc/6493/tasks</code> 查看该进程下的所有 tasks，他们之间有完整的对应关系：</p><p><img src="http://images.notend.cn/WX20180314-173909.png" alt=""></p><blockquote><p>PS: 查看 <code>/proc/6493/tasks</code> 需要 root 权限</p></blockquote><h2 id="Linux-进程调度"><a href="#Linux-进程调度" class="headerlink" title="Linux 进程调度"></a>Linux 进程调度</h2><p>现在的操作系统都是多任务的，为了能让更多的任务能同时在系统上更好的运行，需要一个管理程序来管理计算机上同时运行的各个任务（也就是进程）。这个管理程序就是调度程序，它的功能说起来很简单：</p><ul><li>决定哪些进程运行，哪些进程等待</li><li>决定每个进程运行多长时间</li></ul><p>此外，为了获得更好的用户体验，运行中的进程还可以立即被其他更紧急的进程打断。总之，调度是一个平衡的过程。一方面，它要保证各个运行的进程能够最大限度的使用CPU(即尽量少的切换进程，进程切换过多，CPU的时间会浪费在切换上)；另一方面，保证各个进程能公平的使用CPU(即防止一个进程长时间独占CPU的情况)。</p><h3 id="Linux-进程优先级"><a href="#Linux-进程优先级" class="headerlink" title="Linux 进程优先级"></a>Linux 进程优先级</h3><p>进程提供了两种优先级，一种是普通的进程优先级，第二个是实时优先级。前者适用 <code>SCHED_NORMAL</code> 调度策略，后者可选 <code>SCHED_FIFO</code> 或 <code>SCHED_RR</code> 调度策略。任何时候，实时进程的优先级都高于普通进程，实时进程只会被更高级的实时进程抢占，同级实时进程之间是按照 FIFO（一次机会做完）或者 RR（多次轮转）规则调度的。</p><p>普通进程和实时进程分别用 nice 值和实时优先级（RTPRI）来度量优先级。</p><h4 id="nice-值"><a href="#nice-值" class="headerlink" title="nice 值"></a>nice 值</h4><p>Linux 中，使用 nice 值来设定一个普通进程的优先级，系统任务调度器根据 nice 值合理安排调度。</p><ul><li>nice 的取值范围为 -20 到 19。</li><li>nice 的值越大，进程的优先级就越低，获得 CPU 调用的机会越少，nice值越小，进程的优先级则越高，获得 CPU 调用的机会越多。</li><li>一个 nice 值为 -20 的进程优先级最高，nice 值为 19 的进程优先级最低。</li><li>父进程 fork 出来的子进程 nice 值与父进程相同。父进程 renice，子进程 nice 值不会随之改变。</li></ul><h4 id="实时优先级"><a href="#实时优先级" class="headerlink" title="实时优先级"></a>实时优先级</h4><ul><li>实时优先级的范围是 0～99。</li><li>与 nice 值的定义相反，实时优先级是值越大优先级越高。</li><li>实时进程都是一些对响应时间要求比较高的进程，因此系统中有实时优先级高的进程处于运行队列的话，它们会抢占一般的进程的运行时间。</li></ul><h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>Linux 进程优先级与 nice 值及实时进程优先级的关系：</p><p><img src="http://images.notend.cn/prio-nice-rtpri.png" alt=""></p><p>通过 <code>ps -p</code> 可以看到这几个值之间的对应关系：</p><p><img src="http://images.notend.cn/WX20180315-135011.png" alt=""></p><h4 id="动态优先级"><a href="#动态优先级" class="headerlink" title="动态优先级"></a>动态优先级</h4><p>除此之外，在执行阶段，调度程序通过增加或减少进程静态优先级的值，来达到奖励IO消耗型或惩罚cpu消耗型的进程，调整后的进程称为动态优先级。与之对应的我们前面提到的优先级的值被称为静态优先级。</p><h3 id="调度原理"><a href="#调度原理" class="headerlink" title="调度原理"></a>调度原理</h3><p>优先级，可以决定谁先运行了。但是对于调度程序来说，并不是运行一次就结束了，还必须知道间隔多久进行下次调度。于是就有了时间片的概念。时间片是一个数值，表示一个进程被抢占前能持续运行的时间。也可以认为是进程在下次调度发生前运行的时间(除非进程主动放弃CPU，或者有实时进程来抢占CPU)。时间片的大小设置并不简单，设大了，系统响应变慢(调度周期长)；设小了，进程频繁切换带来的处理器消耗。默认的时间片一般是10ms。</p><p>举个例子说明调度原理的实现<a href="https://www.jianshu.com/p/d80d5d0f7dbe" target="_blank" rel="noopener">1</a>。</p><p>假设系统中只有3个进程ProcessA(NI=+10)，ProcessB(NI=0)，ProcessC(NI=-10)，NI表示进程的nice值，时间片=10ms：</p><ul><li>调度前，把进程优先级按一定的权重映射成时间片(这里假设优先级高一级相当于多5msCPU时间)。假设ProcessA分配了一个时间片10ms，那么ProcessB的优先级比ProcessA高10(nice值越小优先级越高)，ProcessB应该分配105+10=60ms，以此类推，ProcessC分配205+10=110ms。</li><li>开始调度时，优先调度分配CPU时间多的进程。由于ProcessA(10ms),ProcessB(60ms),ProcessC(110ms)。显然先调度ProcessC。</li><li>10ms(一个时间片)后，再次调度时，ProcessA(10ms), ProcessB(60ms), ProcessC(100ms)。 ProcessC刚运行了10ms，所以变成100ms。此时仍然先调度ProcessC。</li><li>再调度4次后(4个时间片)，ProcessA(10ms), ProcessB(60ms),ProcessC(60ms)。此时ProcessB和ProcessC的CPU时间一样，这时得看ProcessB和ProcessC谁在CPU运行队列的前面，假设ProcessB在前面，则调度ProcessB</li><li>10ms(一个时间片)后，ProcessA(10ms), ProcessB(50ms), ProcessC(60ms)。再次调度ProcessC</li><li>ProcessB 和 ProcessC 交替运行，直至 ProcessA(10ms), ProcessB(10ms), ProcessC(10ms)。<br>这时得看ProcessA，ProcessB，ProcessC谁在CPU运行队列的前面就先调度谁。这里假设调度ProcessA</li><li>10ms (一个时间片)后，ProcessA (时间片用完后退出), ProcessB (10ms), ProcessC (10ms)。</li><li>再过2个时间片，ProcessB 和 ProcessC 也运行完退出。</li></ul><p>这个例子很简单，主要是为了说明调度的原理，实际的调度算法虽然不会这么简单，</p><h3 id="进程调度算法-CFS"><a href="#进程调度算法-CFS" class="headerlink" title="进程调度算法 CFS"></a>进程调度算法 CFS</h3><p>Linux上的调度算法是不断发展的，在2.6.23内核以后，采用了“完全公平调度算法”，简称CFS。</p><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>CFS算法的初衷就是让所有进程同时运行在一个CPU上，例如两个进程都需要运行10ms的时间，则CFS算法下，连个进程同时运行在CPU上，且时间为20ms，而不是每个进程分别运行10ms。但是这只是一种理想的运行方式，CFS为了近似这种运行算法，就提出了虚拟运行时间(vruntime)的概念。vruntime记录了一个可执行进程到当前时刻为止执行的总时间（需要以进程总数n进行归一化，并且根据进程的优先级进行加权）。根据vruntime的定义可以知道，vruntime越大，说明该进程运行的越久，所以被调度的可能性就越小。所以我们的调度算法就是每次选择 vruntime 值最小的进程进行调度，内核中使用红黑树可以方便的得到 vruntime 值最小的进程。至于每个进程如何更新自己的 vruntime ？内核中是按照如下方式来更新的： <code>vruntime +=  delta * NICE_0_LOAD/ se.weight</code>；其中：<br><code>NICE_0_LOAD</code> 是个定值，及系统默认的进程的权值；se.weight是当前进程的权重(优先级越高，权重越大)；<br>delta 是当前进程运行的时间；我们可以得出这么个关系：vruntime 与delta 成正比，即当前运行时间越长 vruntime 增长越快<br> vruntime 与 se.weight 成反比，即权重越大 vunruntime 增长越慢。简单来说，一个进程的优先级越高，而且该进程运行的时间越少，则该进程的 vruntime 就越小，该进程被调度的可能性就越高。</p><h4 id="运行时长"><a href="#运行时长" class="headerlink" title="运行时长"></a>运行时长</h4><p>CFS 的运行时间是有当前系统中所有可调度进程的优先级的比重来确定的，假如现在进程中有三个可调度进程A、B、C，它们的优先级分别为5,10,15，则它们的时间片分别为5/30，10/30，15/30。而不是由自己的时间片计算得来的，这样的话，优先级为1，2的两个进程与优先级为50,100的两个进程分的时间片是相同的。简单来说，CFS采用的所有进程优先级的比重来计算每个进程的时间片的，是相对的而不是绝对的。</p><h3 id="Linux-进程组与-Cgroups"><a href="#Linux-进程组与-Cgroups" class="headerlink" title="Linux 进程组与 Cgroups"></a>Linux 进程组与 Cgroups</h3><p>Cgroups是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制。最初由google的工程师提出，后来被整合进Linux内核。也是目前轻量级虚拟化技术 lxc （linux container）的基础之一。</p><p>Cgroups最初的目标是为资源管理提供的一个统一的框架，既整合现有的cpuset等子系统，也为未来开发新的子系统提供接口。现在的cgroups适用于多种应用场景，从单个进程的资源控制，到实现操作系统层次的虚拟化（OS Level Virtualization）。Cgroups提供了以下功能：</p><ul><li>限制进程组可以使用的资源数量（Resource limiting ）。比如：memory子系统可以为进程组设定一个memory使用上限，一旦进程组使用的内存达到限额再申请内存，就会出发OOM（out of memory）。</li><li>进程组的优先级控制（Prioritization ）。比如：可以使用cpu子系统为某个进程组分配特定cpu share。</li><li>记录进程组使用的资源数量（Accounting ）。比如：可以使用cpuacct子系统记录某个进程组使用的cpu时间</li><li>进程组隔离（Isolation）。比如：使用ns子系统可以使不同的进程组使用不同的namespace，以达到隔离的目的，不同的进程组有各自的进程、网络、文件系统挂载空间。</li><li>进程组控制（Control）。比如：使用freezer子系统可以将进程组挂起和恢复。</li></ul><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>任务（task）。在 cgroups 中，任务就是系统的一个进程。</li><li>控制族群（control group）。控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制。</li><li>层级（hierarchy）。控制族群可以组织成 hierarchical 的形式，既一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性。</li><li>子系统（subsytem）。一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。</li></ul><h4 id="cgroups-在-Android-中的应用"><a href="#cgroups-在-Android-中的应用" class="headerlink" title="cgroups 在 Android 中的应用"></a>cgroups 在 Android 中的应用</h4><p>Android中关于 cpu/cpuset/schedtune 三个子系统的应用都是基于进程优先级的。AMS(ActivityManagerService) 和 PMS(PackageManagerService) 等通过 Process 设置进程优先级、调度策略等；android/osProcess JNI通过调用libcutils.so/libutils.so执行getpriority/setpriority/sched_setscheduler/sched_getschedler系统调用或者直接操作CGroup文件节点以达到设置优先级，限制进程CPU资源的目的。</p><ul><li>cpu，这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问，连接在 Android 系统的 /dev/cpuctl 层级结构上。</li><li>cpuset，这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点，连接在 Android 系统的 /dev/cpuset 层级结构上。</li><li>schedtune，是ARM/Linaro为了EAS新增的一个子系统，主要用来控制进程调度选择CPU以及boost触发，连接在 Android 系统的 /dev/stune 层级结构上。</li></ul><p>Android 中在从设置进程优先级到最后映射到不同 cgroups 下的过程，有兴趣的可以参考 <a href="http://blog.csdn.net/omnispace/article/details/73320945" target="_blank" rel="noopener">Android中关于cpu/cpuset/schedtune的应用</a> 这篇文章。我们这里以 cpu 子系统为例介绍一下再 CPU 子系统下是如何控制不同 cgroup 对 CPU 资源的访问。</p><h5 id="CPU-子系统"><a href="#CPU-子系统" class="headerlink" title="CPU 子系统"></a>CPU 子系统</h5><p>CPU 子系统连接的 /dev/cpuctl 层级结构下有两个 cgroup，分别是</p><ul><li><code>/</code>，对应到 Android 的前台进程组。</li><li><code>/bg_non_interactive</code>，对应到 Android 的后台进程组。</li></ul><p>在 cgroup 下定义了一些参数，来控制不同的 cgroup 在使用 cpu 资源时的配置：</p><ul><li><code>cpu.shares</code>：保存了整数值，用来设置 cgroup 分组任务获得 CPU 时间的相对值。</li><li><code>cpu.rt_runtime_us</code>：主要用来设置 cgroup 获得 CPU 资源的周期，单位为微妙。</li><li><code>cpu.rt_period_us</code>：主要是用来设置 cgroup 中的任务可以最长获得 CPU 资源的时间，单位为微秒。</li></ul><p>通过下面的数据我们可以看到，前台进程组和后台进程组的 <code>cpu.share</code> 值相比接近于 20:1，也就是说前台进程组中的应用可以利用 95% 的 CPU，而处于后台进程组中的应用则只能获得 5% 的 CPU 利用率。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/ $ cat /dev/cpuctl/cpu.shares</div><div class="line">1024</div><div class="line">shell@hammerhead:/ $ cat /dev/cpuctl/bg_non_interactive/cpu.shares</div><div class="line">52</div></pre></td></tr></table></figure><p><img src="http://images.notend.cn/WX20180315-165309@2x.png" alt=""></p><p>同样我们也可查看 <code>cpu.rt_period_us</code> 与 <code>cpu.rt_runtime_us</code> 的时间对比：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/ $ cat /dev/cpuctl/cpu.rt_period_us</div><div class="line">1000000</div><div class="line">shell@hammerhead:/ $ cat /dev/cpuctl/cpu.rt_runtime_us                                          </div><div class="line">800000</div></pre></td></tr></table></figure><p>即单个逻辑CPU下每一秒内可以获得0.8秒的执行时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/ $ cat /dev/cpuctl/bg_non_interactive/cpu.rt_period_us</div><div class="line">1000000</div><div class="line">shell@hammerhead:/ $ cat /dev/cpuctl/bg_non_interactive/cpu.rt_runtime_us</div><div class="line">700000</div></pre></td></tr></table></figure><p>即单个逻辑CPU下每一秒内可以获得0.7秒的执行时间。</p><blockquote><p>PS: 最长的获取CPU资源时间取决于逻辑CPU的数量。比如 <code>cpu.rt_runtime_us</code> 设置为200000（0.2秒）， <code>cpu.rt_period_us</code> 设置为1000000（1秒）。在单个逻辑CPU上的获得时间为每秒为0.2秒。 2个逻辑CPU，获得的时间则是0.4秒。</p></blockquote><h4 id="SchedPolicy"><a href="#SchedPolicy" class="headerlink" title="SchedPolicy"></a>SchedPolicy</h4><p>Android 底层对进程分组的操作最后是通过 <code>sched_policy.c</code> 文件中的 <code>set_sched_policy(int tid, SchedPolicy policy)</code> 和 <code>set_cpuset_policy(int tid, SchedPolicy policy)</code> 函数添加到对应的进程组的，调用这两个函数的传递的 <code>SchedPolicy</code> 定义在 <code>sched_policy.h</code> 中，定义不同的调度策略：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Keep in sync with THREAD_GROUP_* in frameworks/base/core/java/android/os/Process.java */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    SP_DEFAULT    = <span class="number">-1</span>,</div><div class="line">    SP_BACKGROUND = <span class="number">0</span>,</div><div class="line">    SP_FOREGROUND = <span class="number">1</span>,</div><div class="line">    SP_SYSTEM     = <span class="number">2</span>,  <span class="comment">// can't be used with set_sched_policy()</span></div><div class="line">    SP_AUDIO_APP  = <span class="number">3</span>,</div><div class="line">    SP_AUDIO_SYS  = <span class="number">4</span>,</div><div class="line">    SP_TOP_APP    = <span class="number">5</span>,</div><div class="line">    SP_CNT,</div><div class="line">    SP_MAX        = SP_CNT - <span class="number">1</span>,</div><div class="line">    SP_SYSTEM_DEFAULT = SP_FOREGROUND,</div><div class="line">&#125; SchedPolicy;</div></pre></td></tr></table></figure><p>在 <code>set_sched_policy</code> 中根据不同的 <code>SchedPolicy</code> 为进程找到不同的进程组，并添加进去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据不同调度策略选择不同的进程组</span></div><div class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</div><div class="line"><span class="keyword">int</span> boost_fd = <span class="number">-1</span>;</div><div class="line"><span class="keyword">switch</span> (policy) &#123;</div><div class="line"><span class="keyword">case</span> SP_BACKGROUND:</div><div class="line">    fd = bg_cgroup_fd;</div><div class="line">    boost_fd = bg_schedboost_fd;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SP_FOREGROUND:</div><div class="line"><span class="keyword">case</span> SP_AUDIO_APP:</div><div class="line"><span class="keyword">case</span> SP_AUDIO_SYS:</div><div class="line">    fd = fg_cgroup_fd;</div><div class="line">    boost_fd = fg_schedboost_fd;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> SP_TOP_APP:</div><div class="line">    fd = fg_cgroup_fd;</div><div class="line">    boost_fd = ta_schedboost_fd;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">    fd = <span class="number">-1</span>;</div><div class="line">    boost_fd = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 添加到对应的进程组</span></div><div class="line"><span class="keyword">if</span> (add_tid_to_cgroup(tid, fd) != <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (errno != ESRCH &amp;&amp; errno != ENOENT)</div><div class="line">        <span class="keyword">return</span> -errno;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><code>set_cpuset_policy</code> 也有类似的逻辑，这里就不重复列举了，有兴趣的可以去看看源码。</p></blockquote><p>在初始化方法中，可以看到对应不同的进程组和映射到不同的 cgroups 层级架构：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static void __initialize(void) &#123;</div><div class="line">    char* filename;</div><div class="line">    if (!access("/dev/cpuctl/tasks", F_OK)) &#123;</div><div class="line">        __sys_supports_schedgroups = 1;</div><div class="line"></div><div class="line">        filename = "/dev/cpuctl/tasks";</div><div class="line">        fg_cgroup_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line">        if (fg_cgroup_fd &lt; 0) &#123;</div><div class="line">            SLOGE("open of %s failed: %s</div><div class="line">", filename, strerror(errno));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        filename = "/dev/cpuctl/bg_non_interactive/tasks";</div><div class="line">        bg_cgroup_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line">        if (bg_cgroup_fd &lt; 0) &#123;</div><div class="line">            SLOGE("open of %s failed: %s</div><div class="line">", filename, strerror(errno));</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        __sys_supports_schedgroups = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#ifdef USE_CPUSETS</div><div class="line">    if (!access("/dev/cpuset/tasks", F_OK)) &#123;</div><div class="line"></div><div class="line">        filename = "/dev/cpuset/foreground/tasks";</div><div class="line">        fg_cpuset_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line">        filename = "/dev/cpuset/background/tasks";</div><div class="line">        bg_cpuset_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line">        filename = "/dev/cpuset/system-background/tasks";</div><div class="line">        system_bg_cpuset_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line">        filename = "/dev/cpuset/top-app/tasks";</div><div class="line">        ta_cpuset_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line"></div><div class="line">#ifdef USE_SCHEDBOOST</div><div class="line">        filename = "/dev/stune/top-app/tasks";</div><div class="line">        ta_schedboost_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line">        filename = "/dev/stune/foreground/tasks";</div><div class="line">        fg_schedboost_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line">        filename = "/dev/stune/background/tasks";</div><div class="line">        bg_schedboost_fd = open(filename, O_WRONLY | O_CLOEXEC);</div><div class="line">#endif</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再回到上面 <code>SchedPolicy</code>  的定义，可以看到 <code>Keep in sync with THREAD_GROUP_* in frameworks/base/core/java/android/os/Process.java</code> 这样的一句注释，看一眼这里 <code>Process.java</code> 对线程组的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Default thread group -</div><div class="line"> * has meaning with setProcessGroup() only, cannot be used with setThreadGroup().</div><div class="line"> * When used with setProcessGroup(), the group of each thread in the process</div><div class="line"> * is conditionally changed based on that thread's current priority, as follows:</div><div class="line"> * threads with priority numerically less than THREAD_PRIORITY_BACKGROUND</div><div class="line"> * are moved to foreground thread group.  All other threads are left unchanged.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_GROUP_DEFAULT = -<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Background thread group - All threads in</div><div class="line"> * this group are scheduled with a reduced share of the CPU.</div><div class="line"> * Value is same as constant SP_BACKGROUND of enum SchedPolicy.</div><div class="line"> * FIXME rename to THREAD_GROUP_BACKGROUND.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_GROUP_BG_NONINTERACTIVE = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Foreground thread group - All threads in</div><div class="line"> * this group are scheduled with a normal share of the CPU.</div><div class="line"> * Value is same as constant SP_FOREGROUND of enum SchedPolicy.</div><div class="line"> * Not used at this level.</div><div class="line"> **/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_GROUP_FOREGROUND = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * System thread group.</div><div class="line"> **/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_GROUP_SYSTEM = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Application audio thread group.</div><div class="line"> **/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_GROUP_AUDIO_APP = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * System audio thread group.</div><div class="line"> **/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_GROUP_AUDIO_SYS = <span class="number">4</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Thread group for top foreground app.</div><div class="line"> **/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_GROUP_TOP_APP = <span class="number">5</span>;</div></pre></td></tr></table></figure><p>可以看到两组定义之间明确的对应关系：</p><table><thead><tr><th>Process 进程组</th><th>SchedPolicy 进程组</th></tr></thead><tbody><tr><td><code>THREAD_GROUP_DEFAULT</code></td><td><code>SP_DEFAULT</code></td></tr><tr><td><code>THREAD_GROUP_BG_NONINTERACTIVE</code></td><td><code>SP_BACKGROUND</code></td></tr><tr><td><code>THREAD_GROUP_FOREGROUND</code></td><td><code>SP_FOREGROUND</code></td></tr><tr><td><code>THREAD_GROUP_SYSTEM</code></td><td><code>SP_SYSTEM</code></td></tr><tr><td><code>THREAD_GROUP_AUDIO_APP</code></td><td><code>SP_AUDIO_APP</code></td></tr><tr><td><code>THREAD_GROUP_AUDIO_SYS</code></td><td><code>SP_AUDIO_SYS</code></td></tr><tr><td><code>THREAD_GROUP_TOP_APP</code></td><td><code>SP_TOP_APP</code></td></tr></tbody></table><p>至于这里的对应关系是怎么传递对接上的，会在后面进行解释。</p><h2 id="Android-的线程调度"><a href="#Android-的线程调度" class="headerlink" title="Android 的线程调度"></a>Android 的线程调度</h2><h3 id="Android-进程生命周期与ADJ"><a href="#Android-进程生命周期与ADJ" class="headerlink" title="Android 进程生命周期与ADJ"></a>Android 进程生命周期与ADJ</h3><p>Android 开发者应该都知道在系统中进程重要性的划分：</p><ul><li>前台进程(Foreground process)</li><li>可见进程(Visible process)</li><li>服务进程(Service process)</li><li>后台进程(Background process)</li><li>空进程(Empty process)</li></ul><p>相信大家都很清楚，这里就不做过多的介绍了，不过对于进程重要性是通过哪些操作发生变更的，以及和我们前面讲的 Linux 进程分组又是怎么关联和映射上的，是下面要讲述的重点。</p><h4 id="Android-进程优先级的相关概念"><a href="#Android-进程优先级的相关概念" class="headerlink" title="Android 进程优先级的相关概念"></a>Android 进程优先级的相关概念</h4><h4 id="oom-score-adj-级别"><a href="#oom-score-adj-级别" class="headerlink" title="oom_score_adj 级别"></a><code>oom_score_adj</code> 级别</h4><p>对于每一个运行中的进程，Linux 内核都通过 proc 文件系统暴露 <code>/proc/[pid]/oom_score_adj</code> 这样一个文件来允许其他程序修改指定进程的优先级，这个文件允许的值的范围是：-1000 ~ +1001之间。值越小，表示进程越重要。当内存非常紧张时，系统便会遍历所有进程，以确定哪个进程需要被杀死以回收内存，此时便会读取 <code>oom_score_adj</code> 这个文件的值。</p><blockquote><p>PS：在Linux 2.6.36之前的版本中，Linux 提供调整优先级的文件是 <code>/proc/[pid]/oom_adj</code> 。这个文件允许的值的范围是-17 ~ +15之间。数值越小表示进程越重要。 这个文件在新版的 Linux 中已经废弃。但你仍然可以使用这个文件，当你修改这个文件的时候，内核会直接进行换算，将结果反映到 <code>oom_score_adj</code> 这个文件上。<br>Android早期版本的实现中也是依赖 <code>oom_adj</code> 这个文件。但是在新版本中，已经切换到使用 <code>oom_score_adj</code> 这个文件。</p></blockquote><p>为了便于管理，ProcessList.java中预定义了 <code>oom_score_adj</code> 的可能取值，这里的预定义值也是对应用进程的一种分类。</p><p><img src="http://images.notend.cn/WX20180315-180054.png" alt=""></p><p>Lowmemorykiller 根据当前可用内存情况来进行进程释放，总设计了6个级别，即上表中“解释列”加粗的行，即 Lowmemorykiller 的杀进程的6档，如下：</p><ul><li><code>CACHED_APP_MAX_ADJ</code></li><li><code>CACHED_APP_MIN_ADJ</code></li><li><code>BACKUP_APP_ADJ</code></li><li><code>PERCEPTIBLE_APP_ADJ</code></li><li><code>VISIBLE_APP_ADJ</code></li><li><code>FOREGROUND_APP_ADJ</code></li></ul><p>系统内存从很宽裕到不足，Lowmemorykiller 也会相应地从 <code>CACHED_APP_MAX_ADJ</code> (第1档)开始杀进程，如果内存还不足，那么会杀 <code>CACHED_APP_MIN_ADJ</code> (第2档)，不断深入，直到满足内存阈值条件。</p><p>ProcessRecord中下面这些属性反应了 <code>oom_score_adj</code> 的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> maxAdj;                 <span class="comment">// Maximum OOM adjustment for this process</span></div><div class="line"><span class="keyword">int</span> curRawAdj;              <span class="comment">// Current OOM unlimited adjustment for this process</span></div><div class="line"><span class="keyword">int</span> setRawAdj;              <span class="comment">// Last set OOM unlimited adjustment for this process</span></div><div class="line"><span class="keyword">int</span> curAdj;                 <span class="comment">// Current OOM adjustment for this process</span></div><div class="line"><span class="keyword">int</span> setAdj;                 <span class="comment">// Last set OOM adjustment for this process</span></div><div class="line"><span class="keyword">int</span> verifiedAdj;            <span class="comment">// The last adjustment that was verified as actually being set</span></div></pre></td></tr></table></figure><h4 id="Process-State"><a href="#Process-State" class="headerlink" title="Process State"></a>Process State</h4><p>对应的在 ActivityManager 重定义了 process_state 级别的划分，Android 系统会在修改进程状态的同时更新 <code>oom_score_adj</code> 的分级：</p><p><img src="http://images.notend.cn/2018-03-15-18-03-57.png" alt=""></p><p>在 ProcessRecord 中，记录了和进程状态相关的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> curProcState = PROCESS_STATE_NONEXISTENT; <span class="comment">// Currently computed process state</span></div><div class="line"><span class="keyword">int</span> repProcState = PROCESS_STATE_NONEXISTENT; <span class="comment">// Last reported process state</span></div><div class="line"><span class="keyword">int</span> setProcState = PROCESS_STATE_NONEXISTENT; <span class="comment">// Last set process state in process tracker</span></div><div class="line"><span class="keyword">int</span> pssProcState = PROCESS_STATE_NONEXISTENT; <span class="comment">// Currently requesting pss for</span></div></pre></td></tr></table></figure><h4 id="Schedule-Group"><a href="#Schedule-Group" class="headerlink" title="Schedule Group"></a>Schedule Group</h4><p>对应到底层进程分组，除了上面提到的 <code>Process.java</code> 定义的不同线程组的定义，同时还为 <code>Activity manager</code> 定义了一套类似的调度分组，和之前的线程分组定义也存在对应关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Activity manager's version of Process.THREAD_GROUP_BG_NONINTERACTIVE</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHED_GROUP_BACKGROUND = <span class="number">0</span>;</div><div class="line"><span class="comment">// Activity manager's version of Process.THREAD_GROUP_DEFAULT</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHED_GROUP_DEFAULT = <span class="number">1</span>;</div><div class="line"><span class="comment">// Activity manager's version of Process.THREAD_GROUP_TOP_APP</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHED_GROUP_TOP_APP = <span class="number">2</span>;</div><div class="line"><span class="comment">// Activity manager's version of Process.THREAD_GROUP_TOP_APP</span></div><div class="line"><span class="comment">// Disambiguate between actual top app and processes bound to the top app</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHED_GROUP_TOP_APP_BOUND = <span class="number">3</span>;</div></pre></td></tr></table></figure><p>在 ProcessRecord 中，也记录了和调度组相关的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> curSchedGroup;          <span class="comment">// Currently desired scheduling class</span></div><div class="line"><span class="keyword">int</span> setSchedGroup;          <span class="comment">// Last set to background scheduling class</span></div></pre></td></tr></table></figure><h3 id="Android-进程优先级的变化"><a href="#Android-进程优先级的变化" class="headerlink" title="Android 进程优先级的变化"></a>Android 进程优先级的变化</h3><p>我们知道影响 Android 应用进程优先级变化的是根据 Android<br>应用组件的生命周期变化相关。<a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="noopener">Android进程调度之adj算法</a> 里面罗列了所有会触发进程状态发生变化的事件，主要包括：</p><h4 id="Actvity"><a href="#Actvity" class="headerlink" title="Actvity"></a>Actvity</h4><ul><li>ActivityStackSupervisor.realStartActivityLocked: 启动Activity</li><li>ActivityStack.resumeTopActivityInnerLocked: 恢复栈顶Activity</li><li>ActivityStack.finishCurrentActivityLocked: 结束当前Activity</li><li>ActivityStack.destroyActivityLocked: 摧毁当前Activity</li></ul><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>位于ActiveServices.java</p><ul><li>realStartServiceLocked: 启动服务</li><li>bindServiceLocked: 绑定服务(只更新当前app)</li><li>unbindServiceLocked: 解绑服务 (只更新当前app)</li><li>bringDownServiceLocked: 结束服务 (只更新当前app)</li><li>sendServiceArgsLocked: 在bringup或则cleanup服务过程调用 (只更新当前app)</li></ul><h4 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h4><ul><li>BQ.processNextBroadcast: 处理下一个广播</li><li>BQ.processCurBroadcastLocked: 处理当前广播</li><li>BQ.deliverToRegisteredReceiverLocked: 分发已注册的广播 (只更新当前app)</li></ul><h4 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h4><ul><li>AMS.removeContentProvider: 移除provider</li><li>AMS.publishContentProviders: 发布provider (只更新当前app)</li><li>AMS.getContentProviderImpl: 获取provider (只更新当前app)</li></ul><h4 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h4><p>位于 <code>ActivityManagerService.java</code></p><ul><li>setSystemProcess: 创建并设置系统进程</li><li>addAppLocked: 创建persistent进程</li><li>attachApplicationLocked: 进程创建后attach到system_server的过程;</li><li>trimApplications: 清除没有使用app</li><li>appDiedLocked: 进程死亡</li><li>killAllBackgroundProcesses: 杀死所有后台进程.即(ADJ&gt;9或removed=true的普通进程)</li><li>killPackageProcessesLocked: 以包名的形式 杀掉相关进程;</li></ul><p>这些事件都会直接或间接调用到 <code>ActivityManagerService.java</code> 中的 <code>updateOomAdjLocked</code> 方法来更新进程的优先级，<code>updateOomAdjLocked</code> 先通过 <code>computeOomAdjLocked</code> 方法负责计算进程的优先级，再通过调用 <code>applyOomAdjLocked</code> 应用进程的优先级。</p><h4 id="computeOomAdjLocked"><a href="#computeOomAdjLocked" class="headerlink" title="computeOomAdjLocked"></a>computeOomAdjLocked</h4><p><code>computeOomAdjLocked</code> 方法负责计算进程的优先级，总计约700行，执行流程比较清晰，步骤如下，由于代码有点多这里就不贴了，想仔细研究的可以比着系统源码看：</p><h5 id="空进程判断"><a href="#空进程判断" class="headerlink" title="空进程判断"></a>空进程判断</h5><p>空进程中没有任何组件，因此主线程也为null（ProcessRecord.thread描述了应用进程的主线程）。</p><p>如果是空进程，则不需要再做后面的计算了。<code>curSchedGroup</code> 直接设置为<br><code>ProcessList.SCHED_GROUP_BACKGROUND</code> 进程调度组即可。</p><h5 id="app-maxAdj-lt-ProcessList-FOREGROUND-APP-ADJ-的情况"><a href="#app-maxAdj-lt-ProcessList-FOREGROUND-APP-ADJ-的情况" class="headerlink" title="app.maxAdj &lt;= ProcessList.FOREGROUND_APP_ADJ 的情况"></a><code>app.maxAdj &lt;= ProcessList.FOREGROUND_APP_ADJ</code> 的情况</h5><p>系统进程或者Persistent进程会通过设置maxAdj来保持其较高的优先级，对于这类进程不用按照普通进程的算法进行计算，直接按照maxAdj的值设置即可，<code>curSchedGroup</code> 设置为<code>THREAD_GROUP_DEFAULT</code> 进程调度组。</p><h5 id="是否有前台优先级"><a href="#是否有前台优先级" class="headerlink" title="是否有前台优先级"></a>是否有前台优先级</h5><table><thead><tr><th>Case</th><th>schedGroup</th><th>adj</th><th>procState </th></tr></thead><tbody><tr><td>当app是当前展示的app</td><td><code>SCHED_GROUP_TOP_APP</code></td><td><code>FOREGROUND_APP_ADJ</code></td><td><code>PROCESS_STATE_CUR_TOP</code> </td></tr><tr><td>当instrumentation不为空时</td><td><code>SCHED_GROUP_TOP_APP</code></td><td><code>FOREGROUND_APP_ADJ</code></td><td><code>PROCESS_STATE_FOREGROUND_SERVICE</code> </td></tr><tr><td>当进程存在正在接收的broadcastrecevier</td><td>是否在前台广播组 ? <code>SCHED_GROUP_DEFAULT</code> : <code>SCHED_GROUP_BACKGROUND</code></td><td><code>FOREGROUND_APP_ADJ</code></td><td><code>PROCESS_STATE_RECEIVER</code></td></tr><tr><td>当进程存在正在执行的service</td><td>是否前台服务 ? <code>SCHED_GROUP_DEFAULT</code> : <code>SCHED_GROUP_BACKGROUND</code></td><td><code>FOREGROUND_APP_ADJ</code></td><td><code>PROCESS_STATE_SERVICE</code></td></tr><tr><td>以上条件都不符合</td><td><code>SCHED_GROUP_BACKGROUND</code></td><td>adj=cachedAdj(&gt;=<code>FOREGROUND_APP_ADJ</code>)</td><td><code>PROCESS_STATE_CACHED_EMPTY</code></td></tr></tbody></table><blockquote><p>PS：Instrumentation 应用是辅助测试用的，正常运行的系统中不用考虑这种应用。</p></blockquote><h5 id="非前台-Activity"><a href="#非前台-Activity" class="headerlink" title="非前台 Activity"></a>非前台 Activity</h5><p>遍历进程中的所有Activity，找出其中优先级最高的设置为进程的优先级。</p><table><thead><tr><th>Case</th><th>schedGroup</th><th>adj</th><th>procState </th></tr></thead><tbody><tr><td>activity可见</td><td><code>SCHED_GROUP_DEFAULT</code></td><td>&lt;=<code>VISIBLE_APP_ADJ</code></td><td>&lt;=<code>PROCESS_STATE_CUR_TOP</code></td></tr><tr><td>activity正在 pausing 或者已经 pause</td><td><code>SCHED_GROUP_DEFAULT</code></td><td>&lt;=<code>PERCEPTIBLE_APP_ADJ</code></td><td>&lt;=<code>PROCESS_STATE_CUR_TOP</code></td></tr><tr><td>activity正在 stoping</td><td>-</td><td>&lt;=<code>PERCEPTIBLE_APP_ADJ</code></td><td>&lt;=<code>PROCESS_STATE_LAST_ACTIVITY</code></td></tr><tr><td>以上都不满足</td><td>-</td><td>-</td><td>&lt;=<code>PROCESS_STATE_CACHED_ACTIVITY</code></td></tr></tbody></table><h5 id="是否有前台服务"><a href="#是否有前台服务" class="headerlink" title="是否有前台服务"></a>是否有前台服务</h5><p>通过 <code>startForeground</code> 启动的 Service 被认为是前台 Service。</p><table><thead><tr><th>Case</th><th>schedGroup</th><th>adj</th><th>procState </th></tr></thead><tbody><tr><td>存在前台service</td><td><code>SCHED_GROUP_DEFAULT</code></td><td><code>PERCEPTIBLE_APP_ADJ</code></td><td><code>PROCESS_STATE_FOREGROUND_SERVICE</code></td></tr><tr><td>存在 Overlay UI</td><td><code>SCHED_GROUP_DEFAULT</code></td><td><code>PERCEPTIBLE_APP_ADJ</code></td><td><code>PROCESS_STATE_IMPORTANT_FOREGROUND</code></td></tr><tr><td>强制前台</td><td><code>SCHED_GROUP_DEFAULT</code></td><td><code>PERCEPTIBLE_APP_ADJ</code></td><td><code>PROCESS_STATE_TRANSIENT_BACKGROUND</code></td></tr></tbody></table><h5 id="是否特殊进程"><a href="#是否特殊进程" class="headerlink" title="是否特殊进程"></a>是否特殊进程</h5><p>特殊类型的进程包括：重量级进程，桌面进程，前一个应用进程，正在执行备份的进程。</p><ul><li>重量级进程是指那些通过Manifest指明不能保存状态的应用进程；</li><li>桌面进程是指 Android 上的 Launcher；</li><li>“前一个应用”是指：在启动新的Activity时，如果新启动的Activity是属于一个新的进程的，那么当前即将被stop的Activity所在的进程便会成为“前一个应用”进程；</li><li>备份进程，进程是否正在进行备份。</li></ul><table><thead><tr><th>Case</th><th>schedGroup</th><th>adj</th><th>procState </th></tr></thead><tbody><tr><td>重量级进程</td><td>&gt;=<code>SCHED_GROUP_BACKGROUND</code></td><td>&lt;=<code>HEAVY_WEIGHT_APP_ADJ</code></td><td>&lt;=<code>PROCESS_STATE_HEAVY_WEIGHT</code></td></tr><tr><td>桌面进程</td><td>&gt;=<code>SCHED_GROUP_BACKGROUND</code></td><td>&lt;=<code>HOME_APP_ADJ</code></td><td>&lt;=<code>PROCESS_STATE_HOME</code></td></tr><tr><td>“前一个应用”进程</td><td>&gt;=<code>SCHED_GROUP_BACKGROUND</code></td><td>&lt;=<code>PREVIOUS_APP_ADJ</code></td><td>&lt;=<code>PROCESS_STATE_LAST_ACTIVITY</code></td></tr><tr><td>备份进程</td><td>-</td><td>&lt;=<code>BACKUP_APP_ADJ</code></td><td>&lt;=<code>PROCESS_STATE_BACKUP</code></td></tr></tbody></table><h5 id="所有-Service-及连接的-Client"><a href="#所有-Service-及连接的-Client" class="headerlink" title="所有 Service 及连接的 Client"></a>所有 Service 及连接的 Client</h5><p>在当前进程满足 <code>adj &gt; ProcessList.FOREGROUND_APP_ADJ                        || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND                        || procState &gt; ActivityManager.PROCESS_STATE_TOP</code> 的状态下遍历所有的Service，并且还需要遍历每一个Service的所有连接。然后根据连接的关系确认客户端进程的优先级来确定当前进程的优先级。</p><p>这里详细记录了在 bindService 过程中，传递的不同的 FLAG 对于 Service 进程和 Client 进程关联计算 adj 级别。由于涉及的分支判断较多，如果想要仔细研究，最好对着代码一一查看。这里只介绍整个过程中涉及到进程调度组发生的变化：</p><ul><li><code>client.curSchedGroup</code> &gt; <code>schedGroup</code></li></ul><p>在某个 client 进行 bindService 过程中，没有设置:</p><table><thead><tr><th>FLAG</th></tr></thead><tbody><tr><td><code>BIND_WAIVE_PRIORITY</code></td></tr><tr><td><code>BIND_NOT_FOREGROUND</code></td></tr><tr><td><code>BIND_IMPORTANT_BACKGROUND</code></td></tr></tbody></table><p>且 client 的 curSchedGroup 大于当前进程的 schedGroup，则需要重新设置当前进程的调度策略；此时，如果有设置 <code>BIND_IMPORTANT</code> 这个 flag，则赋值 <code>client.curSchedGroup</code> 给 <code>schedGroup</code>，否则则将 <code>schedGroup</code> 设置为 <code>SCHED_GROUP_DEFAULT</code>。</p><p><img src="http://images.notend.cn/android-sched-thread-1-1.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((cr.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span>) &#123;</div><div class="line">...</div><div class="line"><span class="keyword">if</span> ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// This will treat important bound services identically to</span></div><div class="line">    <span class="comment">// the top app, which may behave differently than generic</span></div><div class="line">    <span class="comment">// foreground work.</span></div><div class="line">    <span class="keyword">if</span> (client.curSchedGroup &gt; schedGroup) &#123;</div><div class="line">        <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_IMPORTANT) != <span class="number">0</span>) &#123;</div><div class="line">            schedGroup = client.curSchedGroup;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li><code>BIND_ADJUST_WITH_ACTIVITY</code></li></ul><p>如果 client 有设置 <code>Context.BIND_ADJUST_WITH_ACTIVITY</code> 且 client 进程存在前台 Activity 并且 <code>adj &gt; ProcessList.FOREGROUND_APP_ADJ</code>，则根据 client 是否设置 <code>BIND_IMPORTANT</code> flag 来分别设置当前进程的调度策略。</p><p><img src="http://images.notend.cn/android-sched-thread-2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((cr.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span>) &#123;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">if</span> ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">// client 进程存在前台 Activity 并且 adj &gt; ProcessList.FOREGROUND_APP_ADJ</span></div><div class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp;</div><div class="line">        (a.visible || a.state == ActivityState.RESUMED ||</div><div class="line">         a.state == ActivityState.PAUSING)) &#123;</div><div class="line">        adj = ProcessList.FOREGROUND_APP_ADJ;</div><div class="line">        <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_IMPORTANT) != <span class="number">0</span>) &#123;</div><div class="line">                schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        app.cached = <span class="keyword">false</span>;</div><div class="line">        app.adjType = <span class="string">"service"</span>;</div><div class="line">        app.adjTypeCode = ActivityManager.RunningAppProcessInfo</div><div class="line">                .REASON_SERVICE_IN_USE;</div><div class="line">        app.adjSource = a;</div><div class="line">        app.adjSourceProcState = procState;</div><div class="line">        app.adjTarget = s.name;</div><div class="line">        <span class="keyword">if</span> (DEBUG_OOM_ADJ_REASON) Slog.d(TAG, <span class="string">"Raise to service w/activity: "</span></div><div class="line">                + app);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于整计算过程，可以参考 <a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="noopener">Android进程调度之adj算法</a> 里面的总结，不过根据不同的系统版本，会有稍许差异：</p><ul><li>当 service 已启动，则 procState&lt;= <code>PROCESS_STATE_SERVICE</code>；<ul><li>当 service 在 30 分钟内活动过，则adj= <code>SERVICE_ADJ</code>,cached=false;</li></ul></li><li>获取service所绑定的connections<ul><li>当client与当前app同一个进程，则continue;</li><li>当client进程的 ProcState &gt;= <code>PROCESS_STATE_CACHED_ACTIVITY</code>，则设置为空进程</li><li>当进程存在显示的 ui，则将当前进程的 adj 和 ProcState 值赋予给 client 进程</li><li>当不存在显示的 ui，且 service 上次活动时间距离现在超过30分钟，则只将当前进程的 adj 值赋予给 client 进程</li><li>当前进程 adj &gt; client进程adj的情况<ul><li>当 service 进程比较重要时，则设置adj &gt;= <code>PERSISTENT_SERVICE_ADJ</code></li><li>当 client 进程 adj &lt; <code>PERCEPTIBLE_APP_ADJ</code>,且当前进程 adj &gt; <code>PERCEPTIBLE_APP_ADJ</code> 时，则设置 adj = <code>PERCEPTIBLE</code>;</li><li>当 client 进程 adj &gt;= <code>PERCEPTIBLE_APP_ADJ</code> 时，则设置 adj = clientAdj</li><li>否则，设置 adj &gt;= <code>VISIBLE_APP_ADJ</code>；</li><li>若 client 进程不是 cache 进程，则当前进程也设置为非cache进程</li></ul></li><li>当绑定的是前台进程的情况<ul><li>当 client 进程状态为前台时，则设置 mayBeTop = true，并设置 client 进程 procState = <code>PROCESS_STATE_CACHED_EMPTY</code></li><li>当 client 进程状态 &lt; <code>PROCESS_STATE_TOP</code> 的前提下：若绑定前台 service，则 clientProcState = <code>PROCESS_STATE_BOUND_FOREGROUND_SERVICE</code>；否则clientProcState = <code>PROCESS_STATE_IMPORTANT_FOREGROUND</code></li></ul></li><li>当connections并没有绑定前台service时，则clientProcState &gt;= <code>PROCESS_STATE_IMPORTANT_BACKGROUND</code></li><li>保证当前进程procState不会必client进程的procState大</li></ul></li><li>当进程adj &gt; <code>FOREGROUND_APP_ADJ</code>，且 client 进程 activity 可见 或者resumed 或 正在暂停，则设置adj = <code>FOREGROUND_APP_ADJ</code></li></ul><h5 id="所有-ContentProvider-及连接的-client"><a href="#所有-ContentProvider-及连接的-client" class="headerlink" title="所有 ContentProvider 及连接的 client"></a>所有 ContentProvider 及连接的 client</h5><p>ContentProvider 的遍历和 Service 的遍历是类似的，在满足 <code>(adj &gt; ProcessList.FOREGROUND_APP_ADJ                 || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE                 || procState &gt; ActivityManager.PROCESS_STATE_TOP)</code> 的条件下进行两次循环遍，其中涉及到进程调度组发生变更的情况：</p><ul><li><code>client.curSchedGroup &gt; schedGroup</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (client.curSchedGroup &gt; schedGroup) &#123;</div><div class="line">    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>provider 存在外部非framework 的进程依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (cpr.hasExternalProcessHandles()) &#123;</div><div class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.FOREGROUND_APP_ADJ) &#123;</div><div class="line">        adj = ProcessList.FOREGROUND_APP_ADJ;</div><div class="line">        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</div><div class="line">        app.cached = <span class="keyword">false</span>;</div><div class="line">        app.adjType = <span class="string">"ext-provider"</span>;</div><div class="line">        app.adjTarget = cpr.name;</div><div class="line">        <span class="keyword">if</span> (DEBUG_OOM_ADJ_REASON) Slog.d(TAG, <span class="string">"Raise to external provider: "</span> + app);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) &#123;</div><div class="line">        procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>20s之内有人使用过当前进程的 ContentProvider</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (app.lastProviderTime &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (app.lastProviderTime+mConstants.CONTENT_PROVIDER_RETAIN_TIME) &gt; now) &#123;</div><div class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</div><div class="line">        adj = ProcessList.PREVIOUS_APP_ADJ;</div><div class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</div><div class="line">        app.cached = <span class="keyword">false</span>;</div><div class="line">        app.adjType = <span class="string">"recent-provider"</span>;</div><div class="line">        <span class="keyword">if</span> (DEBUG_OOM_ADJ_REASON) Slog.d(TAG, <span class="string">"Raise to recent provider: "</span> + app);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</div><div class="line">        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</div><div class="line">        app.adjType = <span class="string">"recent-provider"</span>;</div><div class="line">        <span class="keyword">if</span> (DEBUG_OOM_ADJ_REASON) Slog.d(TAG, <span class="string">"Raise to recent provider: "</span> + app);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>完整的 adj 的计算过程，依然请参考 <a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="noopener">Android进程调度之adj算法</a> 或者源码：</p><ul><li>当client与当前app同一个进程，则continue;</li><li>当client进程procState &gt;= <code>PROCESS_STATE_CACHED_ACTIVITY</code>，则把client进程设置成procState = <code>PROCESS_STATE_CACHED_EMPTY</code></li><li>没有ui展示，则保证adj &gt;= <code>FOREGROUND_APP_ADJ</code></li><li>当client进程状态= <code>PROCESS_STATE_TOP</code>(前台)时，则设置mayBeTop=true，并设置client进程procState=<code>PROCESS_STATE_CACHED_EMPTY</code>(空进程)</li><li>当client进程状态 &lt; <code>PROCESS_STATE_TOP</code> 时，则 clientProcState = <code>PROCESS_STATE_BOUND_FOREGROUND_SERVICE</code>；</li><li>procState 比clientProcState更大时，则取client端的状态值。</li><li>当 contentprovider 存在外部进程依赖(非framework)时，则设置adj = <code>FOREGROUND_APP_ADJ</code>, procState = <code>PROCESS_STATE_IMPORTANT_FOREGROUND</code></li><li>20s 之内有人使用过当前进程的 ContentProvider，如果 <code>adj &gt; ProcessList.PREVIOUS_APP_ADJ</code>，adj 设置为 <code>PREVIOUS_APP_ADJ</code>，schedGroup 设置为 <code>SCHED_GROUP_BACKGROUND</code>。</li></ul><h5 id="保存计算好的值"><a href="#保存计算好的值" class="headerlink" title="保存计算好的值"></a>保存计算好的值</h5><p>最后会进行一次 <code>adj</code> 和 <code>app.maxAdj</code> 的对比，如果 <code>adj &gt; app.maxAdj</code> 并且 <code>app.maxAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ</code> 则将 schedGroup 设置为 <code>SCHED_GROUP_DEFAULT</code>, 然后保存之前计算的 adj、schedGroup 和 procState。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">app.curAdj = app.modifyRawOomAdj(adj);</div><div class="line">app.curSchedGroup = schedGroup;</div><div class="line">app.curProcState = procState;</div><div class="line">```              </div><div class="line"></div><div class="line">### Android 线程的优先级及变化</div><div class="line"></div><div class="line">Android 线程优先级的变化分为两种，一种是根据上面计算的进程优先级的变化，给 Android 线程带来的变化，另一种是开发者可以在代码中手动改变线程的优先级。</div><div class="line"></div><div class="line">#### 手动设置</div><div class="line"></div><div class="line">##### Java 线程优先级</div><div class="line"></div><div class="line">我们都知道，在利用 Thread 创建线程或者用 ThreadPoolExecutor 创建线程的时候，我们可以为当前设置的线程设置优先级 `setPriority`。这个优先级并不是我们之前讲到的 Nice 值，Java 的优先级分为 10 个等级，取值从 1 到 10，根据取值的大小，优先级越来越高，一般 Android 线程默认启动设置的优先级为 `NORM_PRIORITY = 5`。</div><div class="line"></div><div class="line">虽然 Java 的优先级和 Nice 值不一样，但是它们之间同样存在一定的对应关系，当我们在 Java 层设置优先级的时候，同样会导致 Linux 对应轻量级进程的 Nice 值的变化，它们的对应关系，我们可以在 `thread_android.cc` 中找到它们之间的对应关系：</div><div class="line"></div><div class="line">```c</div><div class="line">static const int kNiceValues[10] = &#123;</div><div class="line">  ANDROID_PRIORITY_LOWEST,                // 1 (MIN_PRIORITY)</div><div class="line">  ANDROID_PRIORITY_BACKGROUND + 6,</div><div class="line">  ANDROID_PRIORITY_BACKGROUND + 3,</div><div class="line">  ANDROID_PRIORITY_BACKGROUND,</div><div class="line">  ANDROID_PRIORITY_NORMAL,                // 5 (NORM_PRIORITY)</div><div class="line">  ANDROID_PRIORITY_NORMAL - 2,</div><div class="line">  ANDROID_PRIORITY_NORMAL - 4,</div><div class="line">  ANDROID_PRIORITY_URGENT_DISPLAY + 3,</div><div class="line">  ANDROID_PRIORITY_URGENT_DISPLAY + 2,</div><div class="line">  ANDROID_PRIORITY_URGENT_DISPLAY         // 10 (MAX_PRIORITY)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void Thread::SetNativePriority(int newPriority) &#123;</div><div class="line">  if (newPriority &lt; 1 || newPriority &gt; 10) &#123;</div><div class="line">    LOG(WARNING) &lt;&lt; "bad priority " &lt;&lt; newPriority;</div><div class="line">    newPriority = 5;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  int newNice = kNiceValues[newPriority-1];</div><div class="line">  pid_t tid = GetTid();</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到它们的对应关系：</p><table><thead><tr><th>Java Priority</th><th>nice值</th></tr></thead><tbody><tr><td>1</td><td>19</td></tr><tr><td>2</td><td>16</td></tr><tr><td>3</td><td>13</td></tr><tr><td>4</td><td>10</td></tr><tr><td>5</td><td>0</td></tr><tr><td>6</td><td>-2</td></tr><tr><td>7</td><td>-4</td></tr><tr><td>8</td><td>-5</td></tr><tr><td>9</td><td>-6</td></tr><tr><td>10</td><td>-8</td></tr></tbody></table><h5 id="通过-Process-设置优先级"><a href="#通过-Process-设置优先级" class="headerlink" title="通过 Process 设置优先级"></a>通过 Process 设置优先级</h5><p>在 Android 中为线程设置优先级，一般鼓励通过 Process 类进行设置，Process 中 <code>setThreadPriority(int priority)</code> 优先级参数和底层Linux 的 Nice 值有一致的对应关系，而且 Process 还提供设置线程组的方法。</p><p>不过需要特别说明的一点是，当我们通过 Process 进行线程优先级设置的以后，并不会改变 Thread 对象里面优先级的值，这从某种角度上来说，是系统的一个 bug。</p><h5 id="Android-线程优先级的控制"><a href="#Android-线程优先级的控制" class="headerlink" title="Android 线程优先级的控制"></a>Android 线程优先级的控制</h5><p>Android 中常见的几种异步方式有 new Thread()、AysncTask、HandlerThread、ThreadPoolExecutor、IntentService。这几种方式中，除了 AysncTask 以外，其他的创建线程的过程中，默认都是和当前线程（一般是 UI 线程）保持一样的优先级，，只有 AysncTask 默认是 <code>THREAD_PRIORITY_BACKGROUND</code> 的优先级，所以为了保证主线程能够拥有较为优先的执行级别，建议在创建异步线程的过程中注意对优先级的控制。</p><h4 id="随着进程改变"><a href="#随着进程改变" class="headerlink" title="随着进程改变"></a>随着进程改变</h4><p>除了开发者手动为线程设置的优先级意外，根据我们上面对 Android 进程变化的分析，可以知道，在程序运行过程中，随着应用状态的变化，Android 进程的调度策略会发生变化，接下来我们继续分析进程调度策略的变化如果改变进程的优先级（也就是主线程的优先级）和其他线程的优先级的。</p><p>在前面计算完进程的优先级后，会通过 <code>applyOomAdjLocked</code> 方法将对应的优先级、adj、进程状态等值应用到进程上，我们注重关注其中关于进程优先级设置的部分。整个执行的过程可以大概总结为：</p><p><img src="http://images.notend.cn/android_thread_schedule_3.png" alt=""></p><p>其中调度组和进程组的映射关系：</p><table><thead><tr><th>调度组</th><th>进程组</th></tr></thead><tbody><tr><td><code>SCHED_GROUP_BACKGROUND</code></td><td><code>THREAD_GROUP_BG_NONINTERACTIVE</code></td></tr><tr><td><code>SCHED_GROUP_TOP_APP</code> <code>SCHED_GROUP_TOP_APP_BOUND</code></td><td><code>THREAD_GROUP_TOP_APP</code></td></tr><tr><td>其他</td><td><code>THREAD_GROUP_DEFAULT</code></td></tr></tbody></table><ul><li>通过设置进程组，改变了进程所在 cgroup，</li><li>通过设置调度策略实现主线程在实时优先级和普通优先级的切换，</li><li>通过设置优先级改变进程 nice 值，同时在底层会改变进程所在的 cgroup。</li></ul><p>由于这段代码不是很长，我们也可以看看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 进程调度组发生变化</span></div><div class="line"><span class="keyword">if</span> (app.setSchedGroup != app.curSchedGroup) &#123;</div><div class="line">    <span class="keyword">int</span> oldSchedGroup = app.setSchedGroup;</div><div class="line">    app.setSchedGroup = app.curSchedGroup;</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (app.waitingToKill != <span class="keyword">null</span> &amp;&amp; app.curReceivers.isEmpty()</div><div class="line">            &amp;&amp; app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) &#123;</div><div class="line">        <span class="comment">// 满足条件直接 kill 掉</span></div><div class="line">        app.kill(app.waitingToKill, <span class="keyword">true</span>);</div><div class="line">        success = <span class="keyword">false</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 调度组映射到进程组</span></div><div class="line">        <span class="keyword">int</span> processGroup;</div><div class="line">        <span class="keyword">switch</span> (app.curSchedGroup) &#123;</div><div class="line">            <span class="keyword">case</span> ProcessList.SCHED_GROUP_BACKGROUND:</div><div class="line">                processGroup = THREAD_GROUP_BG_NONINTERACTIVE;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> ProcessList.SCHED_GROUP_TOP_APP:</div><div class="line">            <span class="keyword">case</span> ProcessList.SCHED_GROUP_TOP_APP_BOUND:</div><div class="line">                processGroup = THREAD_GROUP_TOP_APP;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                processGroup = THREAD_GROUP_DEFAULT;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> oldId = Binder.clearCallingIdentity();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//  设置进程组，对应到底层的 cgroup</span></div><div class="line">            setProcessGroup(app.pid, processGroup);</div><div class="line">            <span class="keyword">if</span> (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) &#123;</div><div class="line">                <span class="comment">// do nothing if we already switched to RT</span></div><div class="line">                <span class="keyword">if</span> (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) &#123;</div><div class="line">                    <span class="comment">// 应用切换成前台应用  mVrController.onTopProcChangedLocked(app);</span></div><div class="line">                    <span class="keyword">if</span> (mUseFifoUiScheduling) &#123;</div><div class="line">                        <span class="comment">// Switch UI pipeline for app to SCHED_FIFO</span></div><div class="line">                        app.savedPriority = Process.getThreadPriority(app.pid);</div><div class="line">                        scheduleAsFifoPriority(app.pid, <span class="comment">/* suppressLogs */</span><span class="keyword">true</span>);</div><div class="line">                        <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</div><div class="line">                            scheduleAsFifoPriority(app.renderThreadTid,</div><div class="line">                                <span class="comment">/* suppressLogs */</span><span class="keyword">true</span>);</div><div class="line">                            <span class="keyword">if</span> (DEBUG_OOM_ADJ) &#123;</div><div class="line">                                Slog.d(<span class="string">"UI_FIFO"</span>, <span class="string">"Set RenderThread (TID "</span> +</div><div class="line">                                    app.renderThreadTid + <span class="string">") to FIFO"</span>);</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (DEBUG_OOM_ADJ) &#123;</div><div class="line">                                Slog.d(<span class="string">"UI_FIFO"</span>, <span class="string">"Not setting RenderThread TID"</span>);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Boost priority for top app UI and render threads</span></div><div class="line">                        setThreadPriority(app.pid, TOP_APP_PRIORITY_BOOST);</div><div class="line">                        <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                setThreadPriority(app.renderThreadTid,</div><div class="line">                                        TOP_APP_PRIORITY_BOOST);</div><div class="line">                            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">                                <span class="comment">// thread died, ignore</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP &amp;&amp;</div><div class="line">                       app.curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) &#123;</div><div class="line">                <span class="comment">// 应用退出前台                  mVrController.onTopProcChangedLocked(app);</span></div><div class="line">                <span class="keyword">if</span> (mUseFifoUiScheduling) &#123;</div><div class="line">                    <span class="comment">// Reset UI pipeline to SCHED_OTHER</span></div><div class="line">                    setThreadScheduler(app.pid, SCHED_OTHER, <span class="number">0</span>);</div><div class="line">                    setThreadPriority(app.pid, app.savedPriority);</div><div class="line">                    <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</div><div class="line">                        setThreadScheduler(app.renderThreadTid,</div><div class="line">                            SCHED_OTHER, <span class="number">0</span>);</div><div class="line">                        setThreadPriority(app.renderThreadTid, -<span class="number">4</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Reset priority for top app UI and render threads</span></div><div class="line">                    setThreadPriority(app.pid, <span class="number">0</span>);</div><div class="line">                    <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</div><div class="line">                        setThreadPriority(app.renderThreadTid, <span class="number">0</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">                Slog.w(TAG, <span class="string">"Failed setting process group of "</span> + app.pid</div><div class="line">                        + <span class="string">" to "</span> + app.curSchedGroup);</div><div class="line">                Slog.w(TAG, <span class="string">"at location"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Binder.restoreCallingIdentity(oldId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到这里我们已经清晰的了解到进程在应用状态变化后，都发生了哪些优先级的变化，接下来还有一个疑团，就是其他线程的优先级的变化，根据观察我们发现，除了主线程的优先级会发生变化，其他子线程在创建以后，除非开发者手动修改其优先级，否则子线程的优先级并不会发生变化。但是在应用状态发生变化的时候，子线程其所在的进程组合主线程（也就是应用进程）是保持一致的，这是由于我们在设置进程组的时候，会遍历当前进程下所有的 task，然后根据不同的 cgroup 子系统设置进程组，这段代码在 <code>android_util_Process.cpp</code> 的 <code>android_os_Process_setProcessGroup(JNIEnv* env, jobject clazz, int pid, jint grp)</code> 方法中：</p><p>这里通过 <code>SchedPolicy sp = (SchedPolicy) grp;</code> 将前文说的 Process 进程组和 SchedPolicy 进程调度组进行对应转化。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">// 打开进程所有 task 目录</div><div class="line">sprintf(proc_path, "/proc/%d/task", pid);</div><div class="line">if (!(d = opendir(proc_path))) &#123;</div><div class="line">    // If the process exited on us, don't generate an exception</div><div class="line">    if (errno != ENOENT)</div><div class="line">        signalExceptionForGroupError(env, errno, pid);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 遍历所有task</div><div class="line">while ((de = readdir(d))) &#123;</div><div class="line">    int t_pid;</div><div class="line">    int t_pri;</div><div class="line"></div><div class="line">    if (de-&gt;d_name[0] == '.')</div><div class="line">        continue;</div><div class="line">    t_pid = atoi(de-&gt;d_name);</div><div class="line"></div><div class="line">    if (!t_pid) &#123;</div><div class="line">        ALOGE("Error getting pid for '%s'</div><div class="line">", de-&gt;d_name);</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t_pri = getpriority(PRIO_PROCESS, t_pid);</div><div class="line"></div><div class="line">    if (t_pri &lt;= ANDROID_PRIORITY_AUDIO) &#123;</div><div class="line">        int scheduler = sched_getscheduler(t_pid);</div><div class="line">        if ((scheduler == SCHED_FIFO) || (scheduler == SCHED_RR)) &#123;</div><div class="line">            // This task wants to stay in its current audio group so it can keep its budget</div><div class="line">            // don't update its cpuset or cgroup</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (isDefault) &#123;</div><div class="line">        if (t_pri &gt;= ANDROID_PRIORITY_BACKGROUND) &#123;</div><div class="line">            // This task wants to stay at background</div><div class="line">            // update its cpuset so it doesn't only run on bg core(s)</div><div class="line">#ifdef ENABLE_CPUSETS</div><div class="line">            int err = set_cpuset_policy(t_pid, sp);</div><div class="line">            if (err != NO_ERROR) &#123;</div><div class="line">                signalExceptionForGroupError(env, -err, t_pid);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int err;</div><div class="line">#ifdef ENABLE_CPUSETS</div><div class="line">    // set both cpuset and cgroup for general threads</div><div class="line">    err = set_cpuset_policy(t_pid, sp);</div><div class="line">    if (err != NO_ERROR) &#123;</div><div class="line">        signalExceptionForGroupError(env, -err, t_pid);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">    err = set_sched_policy(t_pid, sp);</div><div class="line">    if (err != NO_ERROR) &#123;</div><div class="line">        signalExceptionForGroupError(env, -err, t_pid);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">closedir(d);</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Android 应用状态发生变化以后，会导致进程的 <code>oom_score_adj</code>、<code>procState</code>、<code>schedGroup</code> 等进程状态的重新计算和设置，从而改变进程的优先级和调度策略，帮助系统进行更合理资源分配和资源回收。</p><p>Android 中的线程对应到 Linux 的内核中的轻量级进程，所以 Linux 为其分配资源适用 Linux 进程调度策略。其中主线程等同于应用进程的优先级，一般由 Android 系统根据应用状态的变化自行调控，不建议开发者手动设置，不过我们为应用中各子线程设置的优先级，将直接影响到主线程在抢占各种系统资源尤其是 CPU 资源时候的优先级，所以为了保证主线程执行的顺畅，我们应尽量控制子线程的优先级。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>经过一些调试以后，我们发现应用在启动 1-2s 以后，主线程的优先级就从 <code>TOP_APP_PRIORITY_BOOST(-10)</code> 降为 <code>THREAD_PRIORITY_BACKGROUND(10)</code> 后台进程的优先级，这直接导致主线程在大多数情况下的优先级是低于其他线程的，从而在抢占 CPU 资源时处于劣势。根据之前对于 Android 线程调度分析，可以排除是系统降低的可能，同时我们对比了其他应用，发现所有其他应用当处于前台的时候，主线程的优先级都是 <code>TOP_APP_PRIORITY_BOOST(-10)</code>，这进一步加强了对于业务代码误操作导致主线程降低的推断，最后我们通过对  <code>Process.setThreadPriority(priority)</code> 调用的排查，发现的确有一个地方不小心为主线程设置了 <code>THREAD_PRIORITY_BACKGROUND(10)</code> 的优先级。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>可以预测，如果不是这次对于卡顿栈的分析，我们不能确定我们还有多久才能发现这个已经存在很久的 bug，我们依然会这样一个小小的失误而承担巨大的成本，因为在后台线程本身就很多主线程的优先级得不到保障的情况下，应用的卡顿是不可避免的，而且可能做再多其他方面的优化，也于事无补，性能检测和监控的价值就在这里，虽然不能马上让应用有质的飞跃，但一点一滴的优化，我们的应用会变得越来越流畅。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/d80d5d0f7dbe" target="_blank" rel="noopener">从linux到android，进程的方方面面</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-thread/index.html" target="_blank" rel="noopener">Linux 线程实现机制分析</a></li><li><a href="http://blog.csdn.net/ylyuanlu/article/details/8830374" target="_blank" rel="noopener">内核线程、轻量级进程、用户线程的区别和联系</a></li><li><a href="http://www.oschina.net/question/565065_67868" target="_blank" rel="noopener">Android 多线程系统概述及与Linux系统的关系</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-threading.html" target="_blank" rel="noopener">Linux 线程模型的比较：LinuxThreads 和 NPTL</a></li><li><a href="https://www.jianshu.com/p/5a4fc2729c17" target="_blank" rel="noopener">内核线程与用户线程的一点小总结 《程序员的自我修养》</a></li><li><a href="http://gityuan.com/2015/10/11/ps-command/" target="_blank" rel="noopener">ps进程命令</a></li><li><a href="https://droidyue.com/blog/2015/09/05/android-process-and-thread-schedule-nice/" target="_blank" rel="noopener">剖析Android中进程与线程调度之nice</a></li><li><a href="https://www.kancloud.cn/alex_wsc/androidsystem/483951" target="_blank" rel="noopener">深入了解Android系统-进程优先级</a></li><li><a href="https://droidyue.com/blog/2015/09/17/android-process-and-thread-schedule-cgroups/?droid_refer=series" target="_blank" rel="noopener">Android进程线程调度之cgroups</a></li><li><a href="http://blog.csdn.net/jesseyoung/article/details/39077829" target="_blank" rel="noopener">cgroups介绍及安装配置使用详解</a></li><li><a href="http://blog.csdn.net/omnispace/article/details/73320945" target="_blank" rel="noopener">Android中关于cpu/cpuset/schedtune的应用</a></li><li><a href="https://tech.meituan.com/cgroups.html" target="_blank" rel="noopener">Linux资源管理之cgroups简介</a></li><li><a href="http://files.cnblogs.com/files/lisperl/cgroups%E4%BB%8B%E7%BB%8D.pdf" target="_blank" rel="noopener">cgroups介绍.pdf</a></li><li><a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="noopener">Android进程调度之adj算法</a></li><li><a href="http://qiangbo.space/2016-11-23/AndroidAnatomy_Process_OomAdj/" target="_blank" rel="noopener">Android系统中的进程管理：进程的优先级</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;最近我们的 APM 上线了应用卡顿的性能检测，我们使用的是和 BlockCanary 同样的方案，通过 Looper Printer 去监控
      
    
    </summary>
    
    
      <category term="Android" scheme="http://ohmerhe.com/tags/Android/"/>
    
      <category term="Linux" scheme="http://ohmerhe.com/tags/Linux/"/>
    
      <category term="进程" scheme="http://ohmerhe.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 迷人的语言特性（下）</title>
    <link href="http://ohmerhe.com/2017/08/15/kotlin_facinating_feature_2/"/>
    <id>http://ohmerhe.com/2017/08/15/kotlin_facinating_feature_2/</id>
    <published>2017-08-15T14:46:11.000Z</published>
    <updated>2019-01-02T02:38:31.140Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章，我们介绍了 Kotlin 许多迷人的语言特性，包括空安全、类型推断、操作符重载等等，接下来我们继续领略 Kotlin 给我们带来的迷人特性。</p><h2 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h2><p>Kotlin 没有字段（field）的概念，只有属性，Kotlin 为所有的属性自动生成 Setter 和 Getter 方法（常量只有 Getter）方法，对 Kotlin 属性的设置和访问，也都是通过 Setter 和 Getter 方法。利用这个特性，Kotlin 为开发者提供了委托属性，可以将对属性的操作和访问委托个另外一个对象。懒加载和属性观察者，用起来 666。</p><p><img src="http://images.notend.cn/2017-08-06-22-14-42.png" alt=""></p><h2 id="Lambdas-表达式和高阶函数"><a href="#Lambdas-表达式和高阶函数" class="headerlink" title="Lambdas 表达式和高阶函数"></a>Lambdas 表达式和高阶函数</h2><p>Lambdas 表达式是 Kotlin 带给 Android 程序员的又一个期待已久的礼包，在 Java 8 只是 Lambdas 表达式的时候，大家就各种期待能用 Java 8 开发 Android，然而过了这么久，Jack 依然存在各种问题，而且现在还被官方放弃了。不过现在有了 Kotlin，Lambdas 表达式和高阶函数都不在是遥不可及。</p><p><img src="http://images.notend.cn/2017-08-06-22-20-28.png" alt=""></p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>当碰到一个嵌套多级的泛型类型的是，要定义这个类型的变量是通过的，因为我们需要申明这样 <code>MutableMap&lt;K, MutableList&lt;File&gt;&gt;</code> 一个类型，除了书写起来非常费力外，可读性也非常差，有时可能还要比对尖括号的位置来阅读代码。为了解决这样的问题（同样也适用于 Kotlin 的函数类型），Kotlin 提供了类型别名的方式，让你可以为一个复杂的类型定义一个简单类型别名。</p><p><img src="http://images.notend.cn/2017-08-06-22-26-41.png" alt=""></p><h2 id="解构声明"><a href="#解构声明" class="headerlink" title="解构声明"></a>解构声明</h2><p>还记得第一次接触到 Go 的时候，我的同事就对 Go 的同时返回多参数赞不绝口，都后来才发现，只要支持元祖的语言，都可以做到这一点。Kotlin 的解构声明在早期其实也是叫元祖，但是可能由于对元祖功能支持的并不完整，所以后面放弃了这个叫法。针对特定的类型（如：数据类）我们可以快速结构一个对象的得到多个变量，常用在多参数返回和集合迭代中。</p><p><img src="http://images.notend.cn/2017-08-06-22-36-04.png" alt=""></p><h2 id="Kotlin-协程"><a href="#Kotlin-协程" class="headerlink" title="Kotlin 协程"></a>Kotlin 协程</h2><p>Kotlin 协程是 1.1 后引入的一个大的语言特性，现在还是体验阶段，虽然还是体验阶段，但是这个特性实在是太赞了，以至于已经吸引了大家太多的眼球了。Kotlin 协程旨在帮助程序员更方便的处理异步程序，Kotlin 官方提供协程实现库，囊括了现在流行语言中使用协程的一些经典用法，如# 和 ECMAScript 的 async/await 及源于 C# 和 Python generators/yield。</p><p><img src="http://images.notend.cn/8B94B216-105A-47C0-A801-80B8A1237DF3.png" alt=""></p><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>当我们建一个函数或表达式标记成内联函数的时候，Kotlin 编译器会将对应的代码生成在该内联函数调用的地方，这样一方面解决了高阶函数带来的一些运行时的效率损失，同样也为具体化的类型参数（泛型）的实现提供了实现基础。</p><p><img src="http://images.notend.cn/2017-08-06-23-00-17.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kotlin 有太多让人赞不绝口的迷人特性，其中有很多特性本身就值得我们花上好几个篇章来介绍，这里只是简单做了一些汇总，具体各种语言特性的体验，还需要各位看官亲自体验。</p><p>距离 Google I/O 大会已经过去一段时间了，Kotlin 的风暴似乎已经过去，你是不是已经找到自己的理由继续回去写自己的 Java 了。</p><hr><p><img src="http://images.notend.cn/kotlin-three-wechat.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章，我们介绍了 Kotlin 许多迷人的语言特性，包括空安全、类型推断、操作符重载等等，接下来我们继续领略 Kotlin 给我们带来的迷人特性。&lt;/p&gt;
&lt;h2 id=&quot;委托属性&quot;&gt;&lt;a href=&quot;#委托属性&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 迷人的语言特性（上）</title>
    <link href="http://ohmerhe.com/2017/08/15/kotlin_fascinating_feature/"/>
    <id>http://ohmerhe.com/2017/08/15/kotlin_fascinating_feature/</id>
    <published>2017-08-15T14:43:15.000Z</published>
    <updated>2019-01-02T02:38:31.158Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin 今天能够被大家所广泛认识，当然是要依赖于 Google 在 I/O 大会上力挺的结果，然而支撑 Kotlin 从众多语言中脱颖而出的是，它作为一门现代语言，吸收了许多现代语言所有的非常棒的特性，正是这些迷人的语言特性加上 Android 开发的无缝对接，让 Kotlin 一下击败 Java，俘获了大多数 Android 程序员的芳心。</p><h2 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h2><p>空安全是 Kotlin 送给 Android 开发者第一个大礼，所有的 Java 开发者都会被 NullPointException 这个问题所困扰，不管是来自前辈，左辈（同事）、后辈（新手）还是自己坑自己，很多情况很难避免，Kotlin 通过引入可空类型和非空类型，将空安全从「运行时」强制前置到「编译时」，完美的解决了未知空安全的隐患。</p><p><img src="http://images.notend.cn/2017-07-24-00-19-53.png" alt=""></p><h2 id="类型推断与自动强转"><a href="#类型推断与自动强转" class="headerlink" title="类型推断与自动强转"></a>类型推断与自动强转</h2><p>当通过等号右边的的赋值可以明确知道你要定义的变量是什么类型的时候，Kotlin 允许你不为这个变量声明类型，而是自动推测出你想要声明的类型，这可以减少不必要的类型声明，提升开发效率。而且在一个变量如果已经在做过类型判断的是，后面再使用这个变量的时候，Kotlin 也能够自动强转成你想要的类型，而不用再写先判断再手动强转那样傻的代码。</p><p><img src="http://images.notend.cn/2017-07-24-00-25-31.png" alt=""></p><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>我之前写过一篇文章，专门讲述了 Kotlin 函数式三板斧的使用，就是 Kotlin 对集合操作及其方便的一个典型。Kotlin 作为一门支持函数式编程范式的语言，其标准库封装了大量对集合操作的快捷方法，有了这个库，我们基本可以抛弃之前 Java 中对集合操作封装的所有 Utils 方法。</p><p><img src="http://images.notend.cn/2017-07-24-00-30-09.png" alt=""></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>有的人说扩展让「面向扩展开放，面向修改封闭」在语言层面得到了支持，的确 Kotlin 的扩展特性让我们在不修改任何源代码的情况下，可以为类扩展出我们想要的新的方法，这个特性是在太棒了，就好比我们获得了可以在不拆掉一辆汽车就可以为它装上翅膀飞翔一般的能力，虽然和 Swift 相比，Kotlin 的扩展功能还不够强大。</p><p><img src="http://images.notend.cn/2017-07-24-00-38-20.png" alt=""></p><h2 id="区间操作"><a href="#区间操作" class="headerlink" title="区间操作"></a>区间操作</h2><p>Kotlin 让我们可以快速得到一个区间，并对其进行操作。</p><p><img src="http://images.notend.cn/2017-07-24-00-49-35.png" alt=""></p><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>在一些自定义类中，如果我们能够为其自定义一些操作符，那么在我们调用这个方法的时候，就可以大大提高代码的可读性和书写时候的流畅度，也让代码变得极为简洁。</p><p><img src="http://images.notend.cn/2017-07-24-00-52-29.png" alt=""></p><h2 id="默认函数参数"><a href="#默认函数参数" class="headerlink" title="默认函数参数"></a>默认函数参数</h2><p>在 Kotlin 函数的参数中，我们可以为之定义默认值，这样我们在调用这个方法的时候如果这个参数不传递的话，Kotlin 就会使用那个默认参数的值，这样大大减少了 Java 中需要重载函数时既枯燥又无聊的代码复制。</p><p><img src="http://images.notend.cn/2017-07-24-00-58-01.png" alt=""></p><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>当我们调用函数的时候，如果只有某几个参数想要传递，其他的参数都使用默认值，这个时候 Kotlin 的命名参数的特性会让你爱不释手，再也不会看到某个函数四个参数随机组合的重载了。</p><p><img src="http://images.notend.cn/2017-07-24-01-01-51.png" alt=""></p><h2 id="中缀符"><a href="#中缀符" class="headerlink" title="中缀符"></a>中缀符</h2><p>当我们用 infix 修饰一个只有一个参数的成员函数的时候，我们就把可以用中缀符的方式调用这个函数了，看起来实在是太酷了，稍有遗憾的是 Kotlin 并不支持前缀符。</p><p><img src="http://images.notend.cn/2017-07-24-01-09-30.png" alt=""></p><p>Kotlin 还有很多迷人的特性，我们下期继续。</p><hr><p><img src="http://images.notend.cn/kotlin-three-wechat.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kotlin 今天能够被大家所广泛认识，当然是要依赖于 Google 在 I/O 大会上力挺的结果，然而支撑 Kotlin 从众多语言中脱颖而出的是，它作为一门现代语言，吸收了许多现代语言所有的非常棒的特性，正是这些迷人的语言特性加上 Android 开发的无缝对接，让 K
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>玩转 Kotlin 委托属性</title>
    <link href="http://ohmerhe.com/2017/05/22/kotlin_properties_delegate/"/>
    <id>http://ohmerhe.com/2017/05/22/kotlin_properties_delegate/</id>
    <published>2017-05-22T13:04:40.000Z</published>
    <updated>2019-01-02T02:38:31.284Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin</p><h2 id="Kotlin-属性"><a href="#Kotlin-属性" class="headerlink" title="Kotlin 属性"></a>Kotlin 属性</h2><p>要讲 Kotlin 的委托属性，要先从 Kotlin 的属性说起，当然关于属性的定义就不多介绍了。这里介绍一下 Kotlin 区别于 Java 独有的 back field 的概念。用过 Kotlin 的人都知道，Kotlin 的属性是天生带 Setter/Getter 方法的，不过如果要重写他们的话，写法有所不同。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a: String = &quot;1&quot;</div><div class="line">get() = field</div><div class="line">set(value) &#123;</div><div class="line">        field = value</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以看到，当需要重写 Setter/Getter 方法的时候，就需要用到 field 这个新概念，它其实是代表这个域本身。有些人刚开始看到这个东西的时候，可能会觉得很神秘，其实它里面的实现逻辑很简单，就是对应到 Java 中 Setter/Getter 方法，然后 field 在 Java 的方法中就是该属性本身，上面的代码编译后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@NotNull</div><div class="line">private String a = &quot;1&quot;;</div><div class="line"></div><div class="line">@NotNull</div><div class="line">public final String getA() &#123;</div><div class="line">  return this.a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final void setA(@NotNull String value) &#123;</div><div class="line">  Intrinsics.checkParameterIsNotNull(value, &quot;value&quot;);</div><div class="line">  this.a = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>基于这样的逻辑，对于 <code>Kotlin</code> 属性的 <code>lateinit</code> 修饰符的实现原理，就可以很简单的推理出来，在属性的 <code>Getter</code> 方法中先判断该属性是否被赋值，否则的话抛出异常，下面就是一个用 <code>lateinit</code> 修饰的属性生成的 <code>Getter</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@NotNull</div><div class="line">public final String getPropLateInit() &#123;</div><div class="line">  String var10000 = this.propLateInit;</div><div class="line">  if(this.propLateInit == null) &#123;</div><div class="line">     Intrinsics.throwUninitializedPropertyAccessException(&quot;propLateInit&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return var10000;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>讲到这里，反应快的人应该能猜到到，下面要讲的属性委托是基于什么原理实现的了。</p><h2 id="Kotlin-委托属性"><a href="#Kotlin-委托属性" class="headerlink" title="Kotlin 委托属性"></a>Kotlin 委托属性</h2><h3 id="委托属性的声明"><a href="#委托属性的声明" class="headerlink" title="委托属性的声明"></a>委托属性的声明</h3><p>定义一个委托属性的语法是 <code>val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code>，其中 <code>by</code> 后面的就是属性的委托。属性委托不用继承什么特别的接口，只要拥有用 <code>operator</code> 修饰的 <code>getValue()</code> 和 <code>setValue()</code> (适用 var)的函数就可以了。</p><p>需要注意的是在官方的文档里，要求 <code>getValue()</code> 和 <code>setValue()</code> 两个函数提供固定的参数，就像下面的例子一样。但是事实其实并非如此，这里我们先按照官方的说法继续，后面再解释这里的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Delegate &#123;</div><div class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</div><div class="line">        return &quot;$thisRef, thank you for delegating &apos;$&#123;property.name&#125;&apos; to me!&quot;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</div><div class="line">        println(&quot;$value has been assigned to &apos;$&#123;property.name&#125; in $thisRef.&apos;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于参数的描述这里做一个简单描述：</p><ul><li><code>thisRef</code>，属性的拥有者；</li><li><code>property</code>，对属性的描述，是 KProperty&lt;*&gt; 类型或是它的父类；</li><li><code>value</code>，属性的值。</li></ul><h3 id="委托属性的背后实现"><a href="#委托属性的背后实现" class="headerlink" title="委托属性的背后实现"></a>委托属性的背后实现</h3><p>Kotlin 官方在官方标准库里提供委托属性的三个常用场景，作为委托属性的范例。这里重点分析一下 <code>lazy</code> 的背后的实现原理，然后顺带讲一下 <code>Observable</code> 和 <code>storing</code> 的用法。</p><h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h4><p>通过 <code>lazy</code> 我们可以定义一个懒加载的属性，该属性的初始化不会再类创建的时候发生，而是在第一次用到它的时候赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val propLazy: Int by lazy&#123;1&#125;</div></pre></td></tr></table></figure><p>我们查看一下编译后的 <code>bytecode</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LINENUMBER 4 L1</div><div class="line">ALOAD 0</div><div class="line">GETSTATIC PropertiesDemo$propLazy$2.INSTANCE : LPropertiesDemo$propLazy$2;</div><div class="line">CHECKCAST kotlin/jvm/functions/Function0</div><div class="line">INVOKESTATIC kotlin/LazyKt.lazy (Lkotlin/jvm/functions/Function0;)Lkotlin/Lazy;</div><div class="line">PUTFIELD PropertiesDemo.propLazy$delegate : Lkotlin/Lazy;</div><div class="line">L2</div></pre></td></tr></table></figure><p>字节码的可读性太差，我们反编译一下，找到相关的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public PropertiesDemo() &#123;</div><div class="line">  this.propLazy$delegate = LazyKt.lazy((Function0)null.INSTANCE);</div><div class="line">&#125;</div><div class="line">   </div><div class="line">@NotNull</div><div class="line">private final Lazy propLazy$delegate;</div><div class="line"></div><div class="line">static final KProperty[] $$delegatedProperties = new KProperty[]&#123;(KProperty)Reflection.property1(new PropertyReference1Impl(Reflection.getOrCreateKotlinClass(PropertiesDemo.class), &quot;propLazy&quot;, &quot;getPropLazy()I&quot;)))&#125;;</div><div class="line">   </div><div class="line">public final int getPropLazy() &#123;</div><div class="line">  Lazy var1 = this.propLazy$delegate;</div><div class="line">  KProperty var3 = $$delegatedProperties[0];</div><div class="line">  return ((Number)var1.getValue()).intValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到 Kotlin 为我们生成了一个 <code>Lazy</code> 类型的 <code>propLazy$delegate</code> 属性，同时生成一个 <code>getPropLazy()</code> 方法，但是我们并没有找到 <code>propLazy</code> 属性的定义（这一点我们先不管，后面再说）。</p><p>在 <code>getPropLazy()</code> 的实现里可以看到返回的是 <code>propLazy$delegate.getValue()</code> 的值，再看下 <code>propLazy$delegate</code> 的赋值是在类的构造函数里面 <code>this.propLazy$delegate = LazyKt.lazy((Function0)null.INSTANCE);</code>。LazyKt 是系统的 <code>Lazy.kt</code> 文件生成的类文件，找到 <code>Lazy.kt</code> 的 <code>lazy()</code> 方法，返回的是 <code>SynchronizedLazyImpl</code> 的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@kotlin.jvm.JvmVersion</div><div class="line">public fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</div></pre></td></tr></table></figure><p>在 <code>SynchronizedLazyImpl</code> 实现代码里，通过 <code>_value</code> 用来真正保存属性的值。<code>_value</code> 的默认值是 <code>UNINITIALIZED_VALUE</code> (一个自定义的对象)。当 <code>_value</code> 不是默认值的时候，就会直接把 <code>_value</code> 的值作为 <code>getValue()</code> 的返回；当 <code>_value</code> 还是默认值的时候，就会调用 <code>initializer</code> 初始化表达式完成初始化，赋值给 <code>_value</code> 并作为 <code>getValue()</code> 的返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private object UNINITIALIZED_VALUE</div><div class="line">private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123;</div><div class="line">    private var initializer: (() -&gt; T)? = initializer</div><div class="line">    @Volatile private var _value: Any? = UNINITIALIZED_VALUE</div><div class="line">    // final field is required to enable safe publication of constructed instance</div><div class="line">    private val lock = lock ?: this</div><div class="line"></div><div class="line">    override val value: T</div><div class="line">        get() &#123;</div><div class="line">            val _v1 = _value</div><div class="line">            if (_v1 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                @Suppress(&quot;UNCHECKED_CAST&quot;)</div><div class="line">                return _v1 as T</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return synchronized(lock) &#123;</div><div class="line">                val _v2 = _value</div><div class="line">                if (_v2 !== UNINITIALIZED_VALUE) &#123;</div><div class="line">                    @Suppress(&quot;UNCHECKED_CAST&quot;) (_v2 as T)</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    val typedValue = initializer!!()</div><div class="line">                    _value = typedValue</div><div class="line">                    initializer = null</div><div class="line">                    typedValue</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE</div><div class="line"></div><div class="line">    override fun toString(): String = if (isInitialized()) value.toString() else &quot;Lazy value not initialized yet.&quot;</div><div class="line"></div><div class="line">    private fun writeReplace(): Any = InitializedLazyImpl(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们发现 <code>SynchronizedLazyImpl</code> 的 <code>getValue()</code> 方法并没有带参数，在反编译的 <code>getPropLazy()</code> 代码中 <code>KProperty var3 = $$delegatedProperties[0];</code> 这个变量其实根本没有用到，其实在正常的委托的反编译的代码是类似这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return (String)this.propObservable$delegate.getValue(this, $$delegatedProperties[1]);</div></pre></td></tr></table></figure><p>所以说其实我们在定义委托的时候，<code>getValue()</code> 和 <code>setValue()</code> 方法是可以不带参数的，只是官方在编译阶段做了限制，导致我们只能拥有带参数的方法。为了验证如果这个想法，我参考 <code>lazy</code> 实现了一个类似的功能，发现根本不能通过编译。</p><h5 id="关于-propLazy-属性本身"><a href="#关于-propLazy-属性本身" class="headerlink" title="关于 propLazy 属性本身"></a>关于 <code>propLazy</code> 属性本身</h5><p>前面我们有提到在生成的字节码中，并不能找到 <code>propLazy</code> 这个属性的定义，我们先看看官网怎么说的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C &#123;</div><div class="line">    var prop: Type by MyDelegate()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// this code is generated by the compiler instead:</div><div class="line">class C &#123;</div><div class="line">    private val prop$delegate = MyDelegate()</div><div class="line">    var prop: Type</div><div class="line">        get() = prop$delegate.getValue(this, this::prop)</div><div class="line">        set(value: Type) = prop$delegate.setValue(this, this::prop, value)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据官方的文档描述，<code>Kotlin</code> 会自动生成 <code>prop$delegate</code> 属性，并复写 <code>prop</code> 的 <code>Setter/Getter</code> 方法。按照这个说话的话，我们上面在编译后的字节码里面应该是可以找到 <code>propLazy</code> 属性的。</p><p>为了验证这个问题，我首先想到是不是因为这个属性是私有变量，在类里面没有使用，所以 <code>Kotlin</code> 编译器为了优化生成字节码的数量而故意去掉了呢。于是我故意在另外一个方法里尝试输出该属性，但是最后发现在编译后该处的使用被替换成 <code>getPropLazy()</code> 方法的调用，所以看来 <code>propLazy</code> 是真的没有了。</p><p>为了进一步验证这个想法，我们还在运行时用反射的方法去获取该属性，发现的确找不到该属性，最后我们得出结论是委托属性在编译后会生成对应的 <code>prop$delegate</code> （被委托的属性」），然后生成生成委托属性的 <code>Setter/Getter</code> 方法，但是该属性本身并不在类的域定义里面，这个时候尝试用反射的方法直接拿到这个属性是做不到的（当然你可以通过 <code>prop$delegate</code> 反射到你想要的内容）。</p><h3 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h3><p>官方推荐另外一个委托属性的应用就是 <code>Observable</code>，让属性在发生变动的时候可以被关注的地方观察到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class User &#123;</div><div class="line">    var name: String by Delegates.observable(&quot;&lt;no name&gt;&quot;) &#123;</div><div class="line">        prop, old, new -&gt;</div><div class="line">        println(&quot;$old -&gt; $new&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line">    val user = User()</div><div class="line">    user.name = &quot;first&quot;</div><div class="line">    user.name = &quot;second&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;no name&gt; -&gt; first</div><div class="line">first -&gt; second</div></pre></td></tr></table></figure><p>想了解 <code>Observable</code> 的实现方式，大家可以参考前面分析 <code>lazy</code> 的方法，去探究一下。关于 <code>Observable</code> 的进一步实现场景，我们一直有一个想法，就是基于这个特性封装出一套 MVVM 的框架，等到这个框架实现以后，再和大家分享。</p><h3 id="Storing"><a href="#Storing" class="headerlink" title="Storing"></a>Storing</h3><p><code>Storing</code> 的使用场景是被模型的属性全部委托到 <code>Map</code> 的结构去真实的存储数据，用于解析 <code>Json</code> 或者做一些动态的事情。</p><pre><code>class User(val map: Map&lt;String, Any?&gt;) {    val name: String by map    val age: Int     by map}</code></pre><p>不过根据我的了解，一些 Json 的解析库是直接用反射的方式实现的反序列化，根据我们前面的分析，这里根本解析不出来，所以这个场景看来是使用不了了。</p><h2 id="关于-BufferKnife-和-KotterKnife"><a href="#关于-BufferKnife-和-KotterKnife" class="headerlink" title="关于 BufferKnife 和 KotterKnife"></a>关于 <code>BufferKnife</code> 和 <code>KotterKnife</code></h2><h3 id="BufferKnife"><a href="#BufferKnife" class="headerlink" title="BufferKnife"></a><code>BufferKnife</code></h3><p>在 <code>Kotlin</code> 刚推出来的时候，由于不支持 <code>apt</code> ，所以会导致 <code>BufferKnife</code> 这类用注解实现的框架会使用不了，但是  <code>Kotlin</code> 很快就意识到这个问题并推出 <code>kapt</code>。在 <code>kapt</code> 推出来以后其实 <code>BufferKnife</code> 就可以正常使用了，我们也在我们的代码里使用了 <code>BufferKnife</code>。但当时 <code>BufferKnife</code> 在增量编译的时候有时候的确会出一些问题，导致我们那个时候最后选择了放弃，我们自己简单封装下 <code>findViewById</code> 的操作，有兴趣的可以看下 <a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="noopener">AndroidExtension</a> 。可能有些人关于 <code>Kotlin</code> 和 <code>BufferKnife</code> 的冲突信息是来自我们当时不准确的描述，导致认为他们不能一起使用。而且经过这么久的迭代，我相信官方应该早就解决这个问题了。</p><h3 id="KotterKnife"><a href="#KotterKnife" class="headerlink" title="KotterKnife"></a><code>KotterKnife</code></h3><p><code>KotterKnife</code> 这个库的存在可能也是很多人认为 <code>Kotlin</code> 不能使用 <code>BufferKnife</code> 的一个因素。在我看来 <code>KotterKnife</code> 创建的时机是 <code>Kotlin</code> 还不支持 <code>apt</code> 的时候，在  <code>Kotlin</code> 推出 <code>kapt</code> 以后这个库就已经不怎么更新了，而且这个库从来没有发布过一个正式版本，所以可以看出这只是大神在用 <code>Kotlin</code> 做的一些新的尝试而已（这一点我是通过查看代码发现 <code>KotterKnife</code> 主要使用「委托属性」这个特性猜想出来的，仅供参考）。</p><hr><p><img src="http://images.notend.cn/kotlin-three-wechat.jpg" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://github.com/JakeWharton/kotterknife" target="_blank" rel="noopener">kotterknife</a></li><li><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">butterknife</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin&lt;/p&gt;
&lt;h2 id=&quot;Kotlin-属性&quot;&gt;&lt;a href=&quot;#Kotlin-属性&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 属性&quot;&gt;&lt;/a&gt;Kotlin 属性&lt;/h2&gt;&lt;p&gt;要讲 Kotlin 的委托属性，要先从 Kotlin 的属性说起，当然关于属性的定义就不多介绍了。这里介绍一下 Kotlin 区别于 Java 独有的 back field 的概念。用过 Kotlin 的人都知道，Kotlin 的属性是天生带 Setter/Getter 方法的，不过如果要重写他们的话，写法有所不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Swift vs. Kotlin 漫谈之函数定义</title>
    <link href="http://ohmerhe.com/2017/05/22/swiftvskotlin_define_function/"/>
    <id>http://ohmerhe.com/2017/05/22/swiftvskotlin_define_function/</id>
    <published>2017-05-22T05:07:35.000Z</published>
    <updated>2019-01-02T02:38:13.678Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin, Swift</p><p>Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。</p><a id="more"></a><h2 id="技术漫谈"><a href="#技术漫谈" class="headerlink" title="技术漫谈"></a>技术漫谈</h2><p><strong>Swift：</strong></p><p>Hi，又见面了。</p><p><strong>Kotlin：</strong></p><p>恩，上次没分出胜负，这次再来。</p><p><strong>Swift：</strong></p><p>好，今天讲讲函数，你们是怎么定义函数的呀？</p><p><strong>Kotlin：</strong></p><p>我们是这样定义的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun &lt;functionName&gt;(&lt;parameters&gt;)[: &lt;Type&gt;] &#123;</div><div class="line">    &lt;block&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你们呢？</p><p><strong>Swift：</strong></p><p>我们是这么定义的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func &lt;function name&gt;(&lt;parameters&gt;) -&gt; &lt;return type&gt; &#123;</div><div class="line">    &lt;statements&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Kotlin：</strong></p><p>区别就是个 <code>-&gt;</code> 和 <code>:</code> 的区别啊，其它都一样。</p><p><strong>Swift：</strong></p><p>嗯嗯嗯。还有个 <code>func</code> 和 <code>fun</code> 的区别。</p><p><strong>Kotlin：</strong></p><p>我们还可以用「单一表达式」直接声明函数，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun &lt;functionName&gt;(&lt;parameters&gt;)[: &lt;Type&gt;] = &lt;singleExpression&gt;</div></pre></td></tr></table></figure><p>在使用「单一表达式」来声明函数的时候返回的类型可以被推断出来，所以可以忽略不写。</p><p><strong>Swift：</strong></p><p>牛X。</p><p><strong>Kotlin：</strong></p><p>服不？</p><p><strong>Swift：</strong></p><p>不服，说说函数参数吧。</p><p><strong>Kotlin：</strong></p><p>Kotlin 中函数的参数使用帕斯卡尔（Pascal）符号定义，例如 <code>name: type</code>，使用逗号分割不同的参数，必须明确定义参数的类型。</p><p><strong>Swift：</strong></p><p>Swift 的参数也差不多，有外部名和内部名之分，外部名就是实参名，内部名就是形参名。</p><p><strong>Kotlin：</strong></p><p>那是咋定义的？</p><p><strong>Swift：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func f(valueA x: Int, valueB y: Int) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里 valueA 和 valueB 就是外部参数名，x 和 y 是内部参数名<br>函数在调用时要写上外部参数名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(valueA: 1, valueB: 2)</div></pre></td></tr></table></figure><p><strong>Kotlin：</strong></p><p>如果不想写参数名呢？</p><p><strong>Swift：</strong></p><p>那在定义的时候用 _ 指代外部名就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">f(_ x: Int, _ y: Int) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2) // 函数调用</div></pre></td></tr></table></figure><p><strong>Kotlin：</strong> </p><p>666666666666</p><p><strong>Swift：</strong></p><p>你们的参数可以加默认值吗？</p><p><strong>Kotlin：</strong></p><p>可以呀，后面 <code>=</code> 一个值就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun read(off: Int = 0) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Swift：</strong></p><p>我们也是一模一样的。</p><p><strong>Kotlin：</strong></p><p>赞</p><p><strong>Swift：</strong></p><p>再说说可变参数吧，我们可变参数的定义是在参数类型后面加三个点<code>...</code>，然后这个参数就可以当做数组使用了</p><p><strong>Kotlin：</strong></p><p>我们是用 <code>vararg</code> 关键字</p><p><strong>Swift：</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func arithmeticMean(_ numbers: Double...) -&gt; Double &#123;</div><div class="line">    var total: Double = 0</div><div class="line">    for number in numbers &#123;</div><div class="line">        total += number</div><div class="line">    &#125;</div><div class="line">    return total / Double(numbers.count)</div><div class="line">&#125;</div><div class="line">arithmeticMean(1, 2, 3, 4, 5)</div><div class="line">// 结果是 3.0</div><div class="line"></div><div class="line">arithmeticMean(3, 8.25, 18.75)</div><div class="line">// 结果是 10.0</div></pre></td></tr></table></figure><p><strong>Kotlin：</strong></p><p>我们是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123;</div><div class="line">    val result = ArrayList&lt;T&gt;()</div><div class="line">    for (t in ts) // ts is an Array</div><div class="line">        result.add(t)</div><div class="line">    return result</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Swift：</strong></p><p>就是关键字不一样，其它还是非常相似的。</p><p><strong>Kotlin：</strong></p><p>恩，惺惺相惜。</p><h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><h2 id="Swift-中函数的定义"><a href="#Swift-中函数的定义" class="headerlink" title="Swift 中函数的定义"></a>Swift 中函数的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func &lt;function name&gt;(&lt;parameters&gt;) -&gt; &lt;return type&gt; &#123;</div><div class="line">    &lt;statements&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果函数没有返回值，则定义方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func &lt;function name&gt;(&lt;parameters&gt;) &#123;</div><div class="line">    &lt;statements&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func f(x: Int, y: Int) -&gt; Int &#123;    </div><div class="line">return x + y  </div><div class="line">&#125;</div><div class="line"></div><div class="line">f(x: 1, y: 2) // 函数调用</div></pre></td></tr></table></figure><h2 id="Swift-中函数的参数"><a href="#Swift-中函数的参数" class="headerlink" title="Swift 中函数的参数"></a>Swift 中函数的参数</h2><p>函数参数声明方式和声明变量相同，不过函数参数有外部名（实参名）和内部名（形参名）之分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func f(valueA x: Int, valueB y: Int) &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里 valueA 和 valueB 就是外部参数名，x 和 y 是内部参数名<br>函数在调用是必须写上外部参数名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(valueA: 1, valueB: 2)</div></pre></td></tr></table></figure><p>如果想要函数在调用时省略外部参数名，则可以在函数声明时把外部参数名指定为 _（下划线）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">f(_ x: Int, _ y: Int) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">f(1, 2) // 函数调用</div></pre></td></tr></table></figure><p>如果不区分外部和内部参数名，则外部和内部参数名相同，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func f(x: Int, y: Int) -&gt; Int &#123;    </div><div class="line">return x + y  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面这个函数的外部参数名和内部参数名都是 x 和 y</p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>函数参数类型后面加三个点”…”，则可把这个参数声明成可变参数<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func arithmeticMean(_ numbers: Double...) -&gt; Double &#123;</div><div class="line">    var total: Double = 0</div><div class="line">    for number in numbers &#123;</div><div class="line">        total += number</div><div class="line">    &#125;</div><div class="line">    return total / Double(numbers.count)</div><div class="line">&#125;</div><div class="line">arithmeticMean(1, 2, 3, 4, 5)</div><div class="line">// returns 3.0</div><div class="line"></div><div class="line">arithmeticMean(3, 8.25, 18.75)</div><div class="line">// returns 10.0</div></pre></td></tr></table></figure><h2 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h2><p>函数的参数可以指定默认值，这样这个函数在调用是可以省略这个参数<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func f(x: Int, y: Int = 3) -&gt; Int &#123;    </div><div class="line">return x + y  </div><div class="line">&#125;</div><div class="line"></div><div class="line">f(x: 1)</div><div class="line">// 结果为 4</div></pre></td></tr></table></figure><h2 id="Kotlin-函数定义"><a href="#Kotlin-函数定义" class="headerlink" title="Kotlin 函数定义"></a>Kotlin 函数定义</h2><p>Kotlin 用 <code>fun</code> 关键字来声明函数，常见的是用块（block）来声明函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun &lt;functionName&gt;(&lt;parameters&gt;)[: &lt;Type&gt;] &#123;</div><div class="line">    &lt;block&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还可以用「单一表达式」直接声明函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun &lt;functionName&gt;(&lt;parameters&gt;)[: &lt;Type&gt;] = &lt;singleExpression&gt;</div></pre></td></tr></table></figure><p>在用「块」来声明函数的时候，返回的类型只有在没有返回（Kotlin 默认返回 Unit）的时候可以不定义。在使用「单一表达式」来声明函数的时候返回的类型可以被推断出来，所以可以忽略不写。</p><h2 id="Kotlin-中函数的参数"><a href="#Kotlin-中函数的参数" class="headerlink" title="Kotlin 中函数的参数"></a>Kotlin 中函数的参数</h2><p>Kotlin 中函数的参数使用帕斯卡尔（Pascal）符号定义，例如 <code>name: type</code>，使用逗号分割不同的参数，必须明确定义参数的类型。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>Kotlin 的函数中允许直接为参数提供默认值，在调用的时候如果使用默认值可以忽略这个参数不传递。默认参数的定义方式是在类型定义后面用 <code>=</code> 传递默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size()) &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="可变参数-1"><a href="#可变参数-1" class="headerlink" title="可变参数"></a>可变参数</h3><p>对于参数数量可变的情况，在 Kotlin 中可以用 <code>vararg</code> 关键字来标记，和 Java 里面  <code>...</code> 是一个用途。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123;</div><div class="line">    val result = ArrayList&lt;T&gt;()</div><div class="line">    for (t in ts) // ts is an Array</div><div class="line">        result.add(t)</div><div class="line">    return result</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val list = asList(1, 2, 3)</div></pre></td></tr></table></figure><p>关于函数相关的知识，无论是 Swift 还是 Kotlin 都还有很多东西可以 PK，不过这篇这是基础语法篇，想要了解更多的和函数相关的 PK，敬请期待后面的更新。</p><hr><p><img src="http://images.notend.cn/kotlin-three-wechat.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin, Swift&lt;/p&gt;
&lt;p&gt;Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
      <category term="Swift" scheme="http://ohmerhe.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift vs. Kotlin 之变量定义</title>
    <link href="http://ohmerhe.com/2017/05/18/swiftvskotlin_variables/"/>
    <id>http://ohmerhe.com/2017/05/18/swiftvskotlin_variables/</id>
    <published>2017-05-18T05:03:43.000Z</published>
    <updated>2019-01-02T02:38:10.620Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin, Swift</p><p>Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。</p><a id="more"></a><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><h4 id="Kotlin："><a href="#Kotlin：" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>你看下我们 Kotlin 定义变量太酷了，比我们之前用 Java 方便太多了，你们 Swift 声明变量方便吗？</p><h4 id="Swift："><a href="#Swift：" class="headerlink" title="Swift："></a>Swift：</h4><p>哦，你们是怎么样的？</p><h4 id="Kotlin：-1"><a href="#Kotlin：-1" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>我们可以直接这样定义一个变量 <code>val b = 2</code>，Kotlin 可以自行推断变量的类型，要是 Java 就不行了，必须要给每个变量定义类型。</p><h4 id="Swift：-1"><a href="#Swift：-1" class="headerlink" title="Swift："></a>Swift：</h4><p>我们这里也有类型推断的功能，我们声明一个变量直接 <code>let count = 10</code> 就可以了，和你们差不多。</p><h4 id="Kotlin：-2"><a href="#Kotlin：-2" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>咦，你们用 <code>let</code> 声明变量，和我们不太一样。</p><h4 id="Swift：-2"><a href="#Swift：-2" class="headerlink" title="Swift："></a>Swift：</h4><p>是的，我们用 <code>let</code> 声明常量，用 <code>var</code> 声明变量，而且我们常量还分为储值变量和计算变量。</p><h4 id="Kotlin：-3"><a href="#Kotlin：-3" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>储值变量和计算变量？是个什么概念，我们这里没有。</p><h4 id="Swift：-3"><a href="#Swift：-3" class="headerlink" title="Swift："></a>Swift：</h4><p>像 <code>var count = 10</code> 这样的定义就是储值变量。像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;: &lt;type&gt; &#123;</div><div class="line">    get &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">    set(&lt;setter name&gt;) &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样定义为变量自定义了 getter 和 setter 方法，这样每次获取变量值得时候都要经过一些的计算才能得到变量的值，所以叫计算变量。</p><h4 id="Kotlin：-4"><a href="#Kotlin：-4" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>这个和我们定义 getter 和 setter 方法一样吗。我们完整的变量定义是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">    [&lt;getter&gt;]</div><div class="line">    [&lt;setter&gt;]</div></pre></td></tr></table></figure><p>其中 initializer、getter 和 setter 是可以省略的，但是我们没有计算变量这个概念。</p><h4 id="Swift：-4"><a href="#Swift：-4" class="headerlink" title="Swift："></a>Swift：</h4><p>恩，我们定义变量的语法是差不多的，除了 <code>let</code> 和 <code>val</code> 的差别。</p><h4 id="Kotlin：-5"><a href="#Kotlin：-5" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>哎，你们的计算变量能不能给自己赋值啊？如果可以赋值的话，和储值变量有什么差别呢？</p><p>我们 getter 和 setter 方法里面有个「支持域」的概念，可以通过「支持域」直接给变量赋值，所以重写 getter 和 setter 方法也只是实现不一样，本身没有质的差别。</p><h4 id="Swift：-5"><a href="#Swift：-5" class="headerlink" title="Swift："></a>Swift：</h4><p>我们不行，在 getter 和 setter 只能通过另外一个储值变量来保存计算的结果。</p><h4 id="Kotlin：-6"><a href="#Kotlin：-6" class="headerlink" title="Kotlin："></a>Kotlin：</h4><p>这点还是有差异的，因为你们 getter 和 setter 不能给当前变量赋值，只能进行计算的工作，所以你们才有计算变量的概念。</p><h4 id="Swift：-6"><a href="#Swift：-6" class="headerlink" title="Swift："></a>Swift：</h4><p>应该是这样的。</p><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Kotlin 定义变量的完整语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</div><div class="line">    [&lt;getter&gt;]</div><div class="line">    [&lt;setter&gt;]</div></pre></td></tr></table></figure><p>其中 initializer、getter 和 setter 是并不是必须的。在属性类型可以通过 initializer 推断的情况下，属性类型也可以不声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val a: Int = 1  // 直接声明</div><div class="line">val b = 2   // `Int` 类型是推断出来的</div><div class="line">val c: Int  // 在没有初始化赋值的化，需要定义类型</div></pre></td></tr></table></figure><p>Kotlin 制定定义只读变量(read-only variable，又叫常量)和变量(mutable variable)，分别用 <code>val</code> 和 <code>var</code> 关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val a: Int = 1 // 不可再次赋值</div><div class="line">var b: Int = 1 // 可再次赋值</div></pre></td></tr></table></figure><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><p>Swift 声明常量，用 let 关键字，常量的值在初始化后不能被再次修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &lt;constant name&gt;[: &lt;type&gt;] = &lt;expression&gt;</div></pre></td></tr></table></figure><p>Swift 声明储值变量，用 var 关键字，变量的值可以被任意修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;[: &lt;type&gt;] = &lt;expression&gt;</div></pre></td></tr></table></figure><p>Swift 声明计算变量，用 var 关键字，同时需要指定 set 和 get 的方式，仅指定 get 则为只读计算变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var &lt;variable name&gt;: &lt;type&gt; &#123;</div><div class="line">    get &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">    set(&lt;setter name&gt;) &#123;</div><div class="line">        &lt;statements&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Swift 支持类型推断，在有初始值的情况下，可以省去类型声明，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let count: Int = 10 // 常量</div><div class="line">var message: String = &quot;Hello&quot; // 变量</div></pre></td></tr></table></figure><p>可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let count = 10 // Int 类型</div><div class="line">var message = &quot;Hello&quot; // String 类型</div></pre></td></tr></table></figure><p>该课程发布在沪江学习App上，会在该博客上同步更新，有兴趣的可以下载该 App 体验一下。</p><p><img src="http://images.notend.cn/1495082763.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin, Swift&lt;/p&gt;
&lt;p&gt;Kotlin 君和 Swift 君在一个团队一起开发已经很久了，由于平台的差异性，他们经常会进行一些技术上的交流（PK），「Kotlin vs. Swift」课程就是他们在互相切磋是的语录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
      <category term="Swift" scheme="http://ohmerhe.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>使用 Espresso 实现完整覆盖的功能测试</title>
    <link href="http://ohmerhe.com/2017/04/18/espresso_huge_ui_test/"/>
    <id>http://ohmerhe.com/2017/04/18/espresso_huge_ui_test/</id>
    <published>2017-04-18T08:59:14.000Z</published>
    <updated>2019-01-02T02:38:27.162Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Android, 测试</p><p>对于基于 UI 的功能测试的需求其实一直存在，理由其实很简单，不想一直让人去做重复机械的事情，而且可靠性完全是靠人力的堆积产生。然而现在行业大多数公司的功能测试工作依然主要是依靠人工来完成，从我们公司的实践来看我觉得有几个方面的因素的影响。</p><ul><li><p>之前的 UI 测试框架的表现差强人意。就拿我们公司来说，其实测试部门在去年已经实现并推广一套主要基于 UIAutomator 实现的测试平台，但由于对复杂功能的处理能力较弱，基本只能实现部分功能的检测。这样导致的一个结果是，并不能有效减少测试的工作，而只能增加测试的额外工作，因此测试编写测试代码的积极性不是很高。同时由于测试代码的可重复利用性差，导致测试脚本的编写成本和维护成本偏高，实践中大家只用 UI 测试跑一些主流程业务，覆盖范围非常有限。</p></li><li><p>部分测试人员的编码能力不是很强。由于大部分测试人员可能并没有过多的开发经验，所以在编写测试代码时并不能很顺畅的完成自己想要的效果，这样也会导致测试代码项目的推广阻力会比较大。</p></li><li><p>对于怎么编写 UI 测试，并没有一个被大家接受认可的最佳实践。虽然我用 Espresso 实现了一套完整的覆盖方案，但是其实我用的方法和 Google 官方所建议的写法还是有蛮多差异的。</p></li></ul><p>对比上面的几个因素，我觉得更为主要的原因还是在于现有测试平台对于复杂逻辑处理的能力不够，导致对于 UI 测试的依赖性仅仅局限在安装测试和兼容性测试，只能用来跑一些主流程的东西，对于大多数功能还只能依靠人工的方式完成。</p><h2 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h2><p>Espresso 是 Google 在 2013 年推出的 Android UI 测试的开源框架。其实之前我们团队也多多少少对 Espresso 有过一些尝试，但遗憾的是都没有深入的进行实践。一季度我们将 UI 测试作为一个很明确的坑来填以后，发现 Espresso 已经很强大了，经过实践下来我们发现用 Espresso 实现 80-90% 的功能性覆盖测试基本没有什么问题。而且 Espresso 的测试脚本编写起来非常简单，如果测试和开发共同来完成测试代码的编写，能够有效替代测试大量的重复机械的工作。</p><p>下面我就来描述一下我们是怎么用 Espresso 来实现这一样一个完整覆盖的功能性测试平台。这篇文章会讲到一些在使用 Espresso 中遇到的坑，但是并不会在 How-to 的事情上面花太多的精力，如果你对 Espresso 还不是很了解的话，建议先去 <a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html" target="_blank" rel="noopener">官方文档</a> 了解一些，并先进行一些简单的实践。</p><h2 id="ETP-测试方案"><a href="#ETP-测试方案" class="headerlink" title="ETP 测试方案"></a>ETP 测试方案</h2><p>在介绍我们的测试平台方案之前，需要提前说明的是，我们在使用 Espresso 的方式可能和官方 Demo 里所展示的方式不完全一样。为了让我们写的测试代码能够更加灵活和方便的被复用在不同的测试用例中，从而实现更低成本的全功能覆盖，我们进行了一些方案设计，最后实现了我们现在的测试平台。</p><p>给我们的测试方案取了一个高大上的名称——ETP 测试方案，也就是 Espresso Test Platform 的简称。大家如果看过 Google 官方的 Demo 的话，就应该能理解官方的思路其实是每个测试是完成一条完整的逻辑测试，比如完成添加一个笔记的测试逻辑。</p><p><img src="http://images.notend.cn/4A9E3284-F1C5-4ED5-8B7F-3E5D4ACF0475.png" alt=""></p><p>这样的测试流程总结下来有两个比较明显的问题：</p><ul><li><p>每条测试用例需要单独编写，代码的复用性差，导致编写单元测试的成本较高，虽然 Google 官方提供录制测试脚本的功能，但是生成的代码可用性并不强，大多数情况下还是需要靠人来编写。</p></li><li><p>复杂场景的处理能力，这样一条单独的测试流程容易被触发性的弹窗或者引导提示打断，如果在单条测试中做过多的判断，又会让单条测试用例变得臃肿，从而让所有的测试用例都变得臃肿而且难于维护和更新。</p></li></ul><h3 id="单页面测试"><a href="#单页面测试" class="headerlink" title="单页面测试"></a>单页面测试</h3><p>这是我为我们测试平台定义的一个基本测试单位，也是我们整个测试方案里面的一个核心概念。这里有两个方面需要明确一下。</p><ul><li><p>有些人会说这是 Espresso 的标准写法，因为你在定义一个 Espresso 测试文件时就必须要指定一个启动的 Activity。但是从官方的 Demo 来看，他们倾向于这个 Activity 仅仅是一个入口，你应该在完成一条完整的测试用例（你可以根据需要跳转到任何页面）以后再进行相应验证。但是在我们的这里，启动的这个页面（可以是 Activity 或者 Fragment）以后就只做当前页面相关的逻辑测试，如果有页面跳转也仅仅是测试是否能成功跳转，不会再对应的界面产生更多的交互。</p></li><li><p>由于 Espresso 是基于 JUnit 实现的，所以你可以针对单个页面编写多个独立得测试用例，它们会以随机的顺序被调用。在我们的单页面测试中，只有单一的测试入口，然后顺序执行这个页面需要执行的所有测试。</p></li></ul><p>在单页面测试中，会根据需求尽可能覆盖这个页面的所有的功能。这个时候有人可能会说，在不同的应用状态下（比如：登录是否），通过 UI 测试所能产生的逻辑并不一致，怎么做到全覆盖能。我们的解决方案是在这个页面的测试代码中，需要全部覆盖该页面所有的逻辑分支，当开始执行这个单页面测试的时候，是怎么样的状态，就进入怎样的逻辑分支。这个时候又有人开始有疑问了，这样怎么做到全功能覆盖呢。想象力丰富的人可能已经想到了解决方案，我们先给到一张图启发一下，后面再介绍我们引入的下一个概念——测试流。</p><p><img src="http://images.notend.cn/D2653BAE-B2DB-43E4-8A91-0FB9240DBA9A.png?imageView2/1/w/720" alt=""></p><p>PS：如果使用的 MVP 的模式来编写代码的话，你会发现在单个页面需要那些逻辑是非常清晰的。</p><p>虽然上面已经明确定义了单页面测试的写法，但是在实际应用过程中，还是会遇到一些场景，不在定义里面被约束，应该怎么处理会让人产生疑惑，会对单页面测试的能力的覆盖性产生怀疑。下面我列出来的几种情况常见的情况来解释应该怎么坚持单页面测试作为基本单位。</p><h4 id="页面关联性测试"><a href="#页面关联性测试" class="headerlink" title="页面关联性测试"></a>页面关联性测试</h4><p>当涉及到页面互相关联的逻辑，一个典型的场景就是在订阅页面订阅一个任务，然后在订阅列表页需要及时显示最新添加的订阅内容。官方的用例是把它放在一条测试里面就不用说了，在我们的测试方案里面应该怎么处理。</p><p>最后我们选择的方案是分开测试：</p><ul><li><p>在订阅页面进行订阅相关测试，在这个页面只验证是否订阅成功。</p></li><li><p>在订阅列表界面，通过模拟订阅操作，发送一个订阅成功通知给这个页面，测试该页面是否会及时显示最新的订阅内容。</p></li></ul><h4 id="Activity-嵌套多个-Fragment"><a href="#Activity-嵌套多个-Fragment" class="headerlink" title="Activity 嵌套多个 Fragment"></a>Activity 嵌套多个 Fragment</h4><p>由于 Espresso 是以 Activity 为入口的，所以可能会导致产生一些误会，我们的单页面就是完全对应到 Activity，其实在我们的设计里面单页面对应到的独立子页面的，所以 Fragment 可以作为一个单独的「单页面测试存在」。在我们的应用里面，首界面有三个 tab，所以加上 MainActivityTest 这个单页面测试首界面总共有四个单页面测试。</p><h4 id="随机触发性逻辑"><a href="#随机触发性逻辑" class="headerlink" title="随机触发性逻辑"></a>随机触发性逻辑</h4><p>在应用中完成某些任务后，会发送一个全局的广播，然后会在后台触发一些和当前页面没有什么关联弹窗。这种场景对我们的 UI 测试是个挑战，由于的随机性，除非在每次都做大量重复的判断，否则很容易导致 UI 测试被中断失败。</p><p>针对这样的场景我们有个小伙伴提了一个特别好的解决方案：</p><ul><li><p>为这些随机的弹窗测试单独写测试，可以嵌入到在业务上认为合理的单页面测试中</p></li><li><p>一般这样的触发性的弹窗都会有相应的全局性的变量用来控制，在执行其他的单页面测试的时候，则手动将对应的控制开关关闭。</p></li></ul><h3 id="测试流和全功能覆盖"><a href="#测试流和全功能覆盖" class="headerlink" title="测试流和全功能覆盖"></a>测试流和全功能覆盖</h3><p>在每个页面的单页面测试都完成以后，接下来的任务就是怎么有效的将这些单页面组合起来。在单元测试中每个单元测试都是独立的，所以只要保证所有的测试用例被执行过就可以了。但是现在我们的目的是实现功能测试，所以一定会有一些状态下的逻辑需要测试。于是在单页面的基础上我们加入了测试流的概念。</p><p><img src="http://images.notend.cn/BA340370-0A57-4C0A-8FB4-E93B41D51950.png?imageView2/1/w/720" alt=""></p><ul><li>一条测试流其实是不同单页面测试的顺序执行。通过前面的单页面测试来后对应用的产生的输出，变成后面一个单页面测试的输入（如：在某条测试流中需要应用处于登录状态，则可以在整个测试流的第一个单页面测试应该是登录页面测试）。</li><li>单条测试流可以对应到某条业务的一条完整流程，一般会覆盖多个测试用例。</li><li>通过不同的测试流，来测试同一页面中不同的逻辑分支。</li><li>通过测试流的叠加来实现全功能的测试覆盖。这里的逻辑是当每个页面的所有逻辑都被测试过，则实现了全功能的测试覆盖。</li></ul><h2 id="Espresso-的坑"><a href="#Espresso-的坑" class="headerlink" title="Espresso 的坑"></a>Espresso 的坑</h2><p>虽然 Espresso 已经很强大了，但是从2.2这个版本以后，已经很久没有更行新版本了，其实里面还是有很多坑的，在使用 Espresso 的时候需要尽量避免。</p><h3 id="Idling-后面需要有-onView-的阻塞操作才能产生效果"><a href="#Idling-后面需要有-onView-的阻塞操作才能产生效果" class="headerlink" title="Idling 后面需要有 onView 的阻塞操作才能产生效果"></a>Idling 后面需要有 onView 的阻塞操作才能产生效果</h3><p>在刚开始接触 IdlingResource 的时候，对它抱有太多的幻想，以为可以肆无忌惮的处理异步的问题，使用之后才发现问题其实也不少，甚至还有一些明显的 bug。</p><p>在 IdlingResource 的说明文档里说可以总结成这样一句话 <code>you have to use Idling Resources to inform Espresso of the app’s long-running operations.</code>。在这里我们并不能很直白的理解出 IdlingResource 只能用来等待 <code>UI events</code>。也就是说在官方的设计里面，要使用 IdlingResource 来维持对应的后台操作，后面的紧跟着一条 UI 操作或验证，否则将不会生效。这样导致的结果是在一个后台操作完成以后是关闭当前页面的场景，根本无法测试。</p><p>如果这算是 Espresso 的特性的话，下面这个就是一个明显的 bug。</p><h3 id="不同线程-IdlingResource-的-bug"><a href="#不同线程-IdlingResource-的-bug" class="headerlink" title="不同线程 IdlingResource 的 bug"></a>不同线程 IdlingResource 的 bug</h3><p>在进行 UI 测试的时候，有两个主线程需要区分一下，一个是主 App 运行的主线程（[main,5,main]），另一个是 UI 测试跑的主线程（[Instr: android.support.test.runner.AndroidJUnitRunner,5,main]）。我们触发的UI事件都是在 App 主线程里面执行的，如果我们想要在 App 的线程里面做一些操作需要切换到对应的线程操作。如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mActivityTestRule.getActivity().runOnUiThread(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                LogUtils.d(TAG, &quot;runOnUiThread...&quot; + Thread.currentThread());</div><div class="line">                TaskApi.Companion.getMyTasks(0, 10000, &quot;&quot;,  new HSAPICallback&lt;TaskListResult&gt;() &#123;</div><div class="line">                    public void onRequestSuccess(TaskListResult data, int httpStatus,Boolean fromCache) &#123;</div><div class="line">                        super.onRequestSuccess(data, httpStatus, fromCache);</div><div class="line">                        mTasks = data.getDatas();</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure><p>理论上这里进行的异步操作应该和 App 里面执行的异步操作是一样的，可以用 IdlingResource 去守护这样一个后台操作，但是实际使用下来，虽然 IdlingResource 已经接受到对应的异步完成回调，但是并没有回调到被注册的 ResourceCallback。</p><h3 id="hasProperty-异常"><a href="#hasProperty-异常" class="headerlink" title="hasProperty 异常"></a>hasProperty 异常</h3><p>Espresso 用的是 Hamcrest 的语法来进行的验证，理论上应该支持所有 Hamcrest 的写法，但是当我们在使用 hasProperty 这个方法的时候，会发现下面这样的错误。这主要是由于 Android SDK 里面并没有完整 JDK 的库，我们用到这部分刚好在 Android SDK 没有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">java.lang.NoClassDefFoundError: Failed resolution of: Ljava/beans/Introspector;</div><div class="line">at org.hamcrest.beans.PropertyUtil.propertyDescriptorsFor(PropertyUtil.java:47)</div><div class="line">at org.hamcrest.beans.PropertyUtil.getPropertyDescriptor(PropertyUtil.java:28)</div><div class="line">at org.hamcrest.beans.HasPropertyWithValue.propertyOn(HasPropertyWithValue.java:94)</div><div class="line">at org.hamcrest.beans.HasPropertyWithValue.matchesSafely(HasPropertyWithValue.java:81)</div><div class="line">at org.hamcrest.TypeSafeDiagnosingMatcher.matches(TypeSafeDiagnosingMatcher.java:55)</div><div class="line">at org.hamcrest.core.AllOf.matches(AllOf.java:27)</div><div class="line">at org.hamcrest.DiagnosingMatcher.matches(DiagnosingMatcher.java:12)</div><div class="line">at android.support.test.espresso.action.AdapterDataLoaderAction.perform(AdapterDataLoaderAction.java:83)</div><div class="line">at android.support.test.espresso.ViewInteraction$1.run(ViewInteraction.java:144)</div><div class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)</div><div class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:237)</div><div class="line">at android.os.Handler.handleCallback(Handler.java:739)</div><div class="line">at android.os.Handler.dispatchMessage(Handler.java:95)</div><div class="line">at android.os.Looper.loop(Looper.java:135)</div></pre></td></tr></table></figure><p>根据 <a href="http://baiduhix.blogspot.com/2015/07/android-espresso-ondata-error.html" target="_blank" rel="noopener">Android espresso onData error</a> 这篇文章可以找到对应的解决方案，但是实际使用下来效果并不好，主要是 gradle 的 Android 插件在不同的版本里面对于引入 Java Core 的代码处理方式有差别，而且我用的 2.2.3 的版本根本就不能用，所以这里的建议绕过不要使用这个方法，我们最后是通过自己定义了一个 Match 来解决这个问题的。</p><h3 id="Drawerlayout-的坑导致用例执行失败"><a href="#Drawerlayout-的坑导致用例执行失败" class="headerlink" title="Drawerlayout 的坑导致用例执行失败"></a>Drawerlayout 的坑导致用例执行失败</h3><p>在官方 Support 包里面的 Drawerlayout 控件有个特性，就是当你触摸到它的触发区域就会发出一个延时操作（160ms），如果这段时间内没有子试图触发事件（如没有及时抬起手指）就会自动触发 Peek 动画，从而导致子试图的事件得不到响应。</p><p>Espresso 的 perform(click()) 操作是先后发送了一个 EventDown 和 EventUp 事件，由于是异步发送的，所以没法保证每次两个事件的执行间隔在 160ms 之内，所以如果在 Drawerlayout 的拖拽相应区域内针对其他子试图的点击事件有可能得不到相应，从而导致用例执行失败。</p><p>这种失败并不是业务逻辑出错，完全是 Drawerlayout 控件设计不合理导致的，而且 Google 的大神们根本没有提供关闭这个功能的接口（他们这么任性不是一次两次了）。 Drawerlayout 是官方提供的控件，你可以选择不使用这个控件自定义一个。我们的解决方案是通过 AOP 的方式在 Drawerlayout 发送这个延时操作以后马上将他从执行队列里移除，从而实现将它这个功能关闭的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Pointcut(&quot;execution(* android.support.v4.widget.DrawerLayout.ViewDragCallback.onEdgeTouched(..))&quot;)</div><div class="line">public void edgeTouchedPoint() &#123;&#125;</div><div class="line"></div><div class="line">@After(&quot;edgeTouchedPoint()&quot;)</div><div class="line">public void onExecutionPoint(final JoinPoint joinPoint) throws Throwable &#123;</div><div class="line">    Reflect.on(joinPoint.getTarget()).call(&quot;removeCallbacks&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>经过诸多尝试和实践，虽然过程中碰到了很多的问题，但最后都逐个被解决，证明用 Espresso 实现全功能覆盖的可行性。我们的方案已经开始实施，截止到现在虽然还没有完全实现覆盖，但是已经完成的部分已经开始产生效果，多次检测到由于开发不小心而导致的 bug，提高了产品的提测质量。可以预见在该方案完整实施后，将对产品质量有一个稳定、高效的保证。</p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul><li><a href="https://google.github.io/android-testing-support-library/docs/espresso/index.html" target="_blank" rel="noopener">espresso</a></li><li><a href="http://stackoverflow.com/questions/33120493/espresso-idling-resource-doesnt-work" target="_blank" rel="noopener">Espresso Idling Resource doesn’t work</a></li><li><a href="http://baiduhix.blogspot.com/2015/07/android-espresso-ondata-error.html" target="_blank" rel="noopener">Android espresso onData error</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tags: Android, 测试&lt;/p&gt;
&lt;p&gt;对于基于 UI 的功能测试的需求其实一直存在，理由其实很简单，不想一直让人去做重复机械的事情，而且可靠性完全是靠人力的堆积产生。然而现在行业大多数公司的功能测试工作依然主要是依靠人工来完成，从我们公司的实践来看我觉得有几个方
      
    
    </summary>
    
    
      <category term="Android" scheme="http://ohmerhe.com/tags/Android/"/>
    
      <category term="测试" scheme="http://ohmerhe.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>在树莓派上用 Docker 安装 Gogs</title>
    <link href="http://ohmerhe.com/2016/12/29/raspberry_install_gogs_with_docker/"/>
    <id>http://ohmerhe.com/2016/12/29/raspberry_install_gogs_with_docker/</id>
    <published>2016-12-29T15:07:43.000Z</published>
    <updated>2019-01-02T02:38:31.386Z</updated>
    
    <content type="html"><![CDATA[<p>这里假设在你的树莓派上已经装好了 Docker，之前装 Docker 的时候稍微折腾了一下，但是遗憾的是，当时没有记录下来，后面有机会再分享这一部分。</p><p>通过搜索可以找到 <code>Gogs</code> 官方为树莓派提供的 Docker 镜像，直接拉取下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># Pull image from Docker Hub.</div><div class="line">$ sudo docker pull gogs/gogs-rpi:0.9.46</div><div class="line"></div><div class="line"># Create local directory for volume.</div><div class="line">$  mkdir -p /var/gogs</div><div class="line"></div><div class="line"># Use `docker run` for the first time.</div><div class="line">$ sudo docker run --name=gogs -p 10022:22 -p 10080:3000 -v /var/gogs:/data gogs/gogs-rpi:0.9.46</div><div class="line"></div><div class="line"># Use `docker start` if you have stopped it.</div><div class="line">$ sudo docker start gogs</div></pre></td></tr></table></figure><p>这样你就可以通过访问 <code>localhost:10080</code> 访问 <code>Gogs</code> 页面了（你也可以通过 <code>ip</code> 访问）,第一次进去是需要配置一下的。数据库的话，如果你是自己个人用的话，可以直接选 <code>SQLite</code>，简单一点。如果是提供给大家的公共服务，可以选择 <code>MYSQL</code> 或者 <code>POSTGRES</code>。由于使用 Docker 的原因，这里有几个配置需要额外注意。</p><ul><li><code>Domain</code>，访问 <code>Gogs</code> 的域名，如果你要提供给外部机器访问的话，这里要填你的机器的 <code>ip</code> 或者域名；</li><li><code>HTTP Port</code>，这里要填 <code>Gogs</code> 在容器里的监听的端口号，一般是 <code>3000</code>；</li><li><code>SSH Port</code>，与上面的相反，这里要填机器暴露给访问者的端口，而不是容器内部 SSH 服务监听的端口，如我们用 <code>10022:22</code> 通过 <code>10022</code> 端口暴露，则使用 <code>10022</code> 这个值；</li><li><code>ROOT_URL</code>，是提供给外部访问网站的公开 URL，如 <code>http://192.168.99.100:10080/</code>。</li></ul><p>其他的都可以使用默认值。如果在配置完了以后发现有配的不对的地方，也可以通过修改 <code>/var/gogs/gogs/conf/app.ini</code> 这个文件，再重启服务。</p><p>这些信息配置好以后，就可以进入网站了。 <code>Gogs</code> 和 <code>Gitlab</code> 有一点差别，默认并不提供一个管理员账号，而是将第一个注册的账号默认设置为管理员账号，这个账号是不需要邮箱验证的。</p><p>更多关于 Gogs 在 Docker 的配置信息可以参考 <a href="https://github.com/gogits/gogs/tree/master/docker" target="_blank" rel="noopener">Docker for Gogs</a>，关于更多 Gogs 的配置信息可以参考 <a href="https://gogs.io/docs/advanced/configuration_cheat_sheet.html" target="_blank" rel="noopener">Configuration Cheat Sheet</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/gogits/gogs/tree/master/docker" target="_blank" rel="noopener">Docker for Gogs</a></li><li><a href="https://gogs.io/docs/advanced/configuration_cheat_sheet.html" target="_blank" rel="noopener">Configuration Cheat Sheet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里假设在你的树莓派上已经装好了 Docker，之前装 Docker 的时候稍微折腾了一下，但是遗憾的是，当时没有记录下来，后面有机会再分享这一部分。&lt;/p&gt;
&lt;p&gt;通过搜索可以找到 &lt;code&gt;Gogs&lt;/code&gt; 官方为树莓派提供的 Docker 镜像，直接拉取下来。
      
    
    </summary>
    
    
      <category term="树莓派" scheme="http://ohmerhe.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Docker" scheme="http://ohmerhe.com/tags/Docker/"/>
    
      <category term="Git" scheme="http://ohmerhe.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>沪江学习安卓端应用架构重构</title>
    <link href="http://ohmerhe.com/2016/12/24/hjstudy_android_refactor/"/>
    <id>http://ohmerhe.com/2016/12/24/hjstudy_android_refactor/</id>
    <published>2016-12-24T05:51:56.000Z</published>
    <updated>2019-01-02T02:38:31.068Z</updated>
    
    <content type="html"><![CDATA[<p>对于大的架构重构，其实我们一直很谨慎的。我们的原则是将重构融合在每次迭代中，逐步优化代码的结构。这次针对整个应用的架构的调整的背景是公司移动开发部门的人数和项目越来越多，当初设计的移动端的架构让项目的依赖关系越来越复杂，维护成本也越来越高。刚好赶上公司产品的特别需求，我们决定梳理并优化一下整个项目解构。最后，我们还是将整个重构的过程融合在每个迭代中，逐步完成一次大的架构升级。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p><img src="http://images.notend.cn/2016-11-21-18-00-43.png" alt=""></p><p>如图所示，这次重构围绕一个老生常谈的概念「解耦」展开，设定几个目标：</p><ul><li>清晰划分各模块的角色</li><li>明确架构层级及各个模块所在的层级</li><li>提高整个架构横向扩展的能力</li><li>提高编译效率，由于我们项目大量使用 Kotlin 开发和 AOP 技术，在编译上面个比较耗时，期望在架构调整后，在整个项目的编译效率上又一次大的提升</li><li>各模块独立开发，面向接口和协议编程</li><li>提高可维护性</li></ul><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>在重构之前，我们的应用架构可以大致分为两层，应用层和 Library 层。一些通用的 Library 主要由专门的部门的同事维护，各业务线也会有一些自己维护的依赖库，也属于 Library 层。各业务线的主应用通过直接依赖的方式使用所需要 Library 提供的功能。</p><p><img src="http://images.notend.cn/2016-11-22-13-38-20.png" alt=""></p><p>各个 Library 之间的依赖关系也是通过直接依赖的方式，由于没有一个明确的层级划分，随着 Library 数量的不断增加，他们之间的依赖关系变得越来越复杂，大致是这样一个状态。</p><p><img src="http://images.notend.cn/2016-11-22-13-32-46.png" alt=""></p><p>这样的应用架构在一个相对小的团队中，可以很好的满足需求，将单独的功能模块和业务模块直接抽离成依赖库的方式去维护，可以降低模块之间的耦合性，又能保证不同应用能够使用统一的公共服务（Library）。但当开发团队发展到一定规模，由于模块数据的增加，模块之间的依赖关系错综复杂，各业务线的业务需求千差万别，这样简单的架构就会显得捉襟见肘了。下面的情况常常让人很头疼。</p><ul><li><p>依赖库之间的强依赖。其中一个最为突出的问题，就是库与库之间的强依赖关系。比如我用了一个库 A，A 使用 B 库来实现网络访问，但是在我的主项目中 C 来实现的网络请求。这种情况就会导致在主项目中同时依赖了两个网络请求库。</p></li><li><p>未知调用潜在风险大，版本升级成本高。由于没有明确的接口约定，往往会发生修改某个看似不会被外面调用到的方法，却导致某个项目的崩溃。同时由于依赖关系的复杂性，当一个项目发生升级以后，需要花很大的精力去确定到具体影响到哪些项目。</p></li><li><p>模块方案发生变化，上层修改成本大。由于是直接依赖的方式，在使用依赖库的时候，大家常常是直接使用库里面提供的接口，这样当某个功能需要切换实现方案的时候往往会导致上层代码的大量修改。</p></li><li><p>依赖库之间的版本冲突。主项目依赖的某库的版本和依赖库里面所依赖的同样的库的版本发生冲突。</p></li><li><p>功能模块兼容性导致维护成本大。在层次关系不够清晰、只有模块划分的时候，各业务线对公共模块需求有所差异，导致库的兼容代码越来越多，不易维护。甚至当某个模块为了满足某个业务线的特殊需求而影响到其他业务的正常使用。</p></li></ul><p>上面的这些问题，如果在规模相对小的团队中，也许表现的不是特别突出，但是当团队规模到达一定程度，存在多条主开发团队在开发不同的业务，同时又想共用许多公共模块的时候，就会经常困扰开发团队。我们可用通过一些规范或约定来规范大家的行为减少这些问题发生，也可以通过构建一些辅助工具或平台帮助我们将一些问题提前暴露出来而不至于影响到线上应用，但这终究是治标不治本。</p><h2 id="重构方案"><a href="#重构方案" class="headerlink" title="重构方案"></a>重构方案</h2><p>整个架构的核心思想是面向接口编程和依赖注入使各个模块之间实现解耦，然后通过横向角色划分与纵向层级划分的方式约定各个模块之间的关系，再通过接口分层的方式，明确具体模块在不同层级上需要实现的功能，最后 AOP 横向切入的方式，去实现测试、调试工具、插桩等行为。</p><h3 id="面向接口与依赖注入"><a href="#面向接口与依赖注入" class="headerlink" title="面向接口与依赖注入"></a>面向接口与依赖注入</h3><p>面向接口和依赖注入是我们这次重构的核心思想，通过接口的方式，约定各个模块对外暴露的功能，再用依赖注入的方式实现模块间的完全解耦。</p><h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p>面向接口编程的概念可以在网上找到很多描述，上面详细的说明了面向接口编程的好处。这里我简单说一下我们想要使用面向接口编程的理由：</p><ul><li><p>只暴露想暴露的部分，在直接依赖的开发模式下，开发人员对于另一个依赖库提供的接口没有一个清晰的界限，常常使用到了该库的设计人员并没有计划暴露的方法。这样在该库升级的时候，就不会考虑到这些方法的版本兼容，以至于导致意想不到的意外。</p></li><li><p>改变编程方式，由于开发过程中，开发人员容易处在边开发边设计的状态，尤其是对于一些入门不是很久的开发，根本没有提前抽象和整理需求的习惯。通过面向接口编程的方式可以逼迫开发人员在开始编写代码之前，进行更多的思考，和其他人达成共识。</p></li><li><p>对需求的高度抽象，在使用面向接口的方式时，由于接口是对某个功能需求抽象，所以不会对具体的实现形成依赖，当某个功能需求的具体实现需要发生改变时，对于使用该功能的调用方完全是透明。 </p></li></ul><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>依赖注入在我们看来是在面向接口编程的基础上再往前走了一步，让模块之间彻底解耦。在单纯的面向接口编程中，如果你需要使用某个功能模块的功能，你本身还是需要依赖对应的模块，并且需要初始化对应的实现。通过依赖注入的方式，使用方本身不用关注具体实现的初始化。而是由统一的注入模块将实现注入，调用方只需要和接口进行交互。这样做的好处是让模块间彻底解耦，也不会担心由于引入某个依赖库而导致引入一些本不想引入的库。</p><h3 id="层级划分与角色划分"><a href="#层级划分与角色划分" class="headerlink" title="层级划分与角色划分"></a>层级划分与角色划分</h3><p>在我们的架构中，总体分为三个层次：底层、组件层和应用层。</p><p><img src="http://images.notend.cn/2016-12-20-14-59-03.png" alt=""></p><ul><li><p>底层，底层是包含三个部分，分别为接口层、基础类层、SDK 扩展层。接口层是对上层功能组件和业务组件的接口定义。基础类层是本公司对一些 Android 原生类的进一步封装，这种封装往往抽象了本公司某些类的共有需求，但不含有任何具体业务的实现，如 BaseActivity 这种。SDK 层是对 Android 原生提供接口的强化或扩展，如对线程管理的优化。当在公司选定某种框架作为底层框架时（如：Kotlin 的标准库）也属于底层的 SDK。</p></li><li><p>组件层，分为功能组件、业务组件和试图组件。功能组件往往是技术实现的封装，如网络请求模块、图片加载模块等。业务组件包含两个部分，一是公司通用业务的封装，如登录模块、意见反馈模块等；二是业务线自己为了解耦拆分出来的子业务模块。试图组件是大家平时积累的通用试图组件。</p></li><li><p>应用层，在我们的架构中，应用层的东西应该很少，主要负责对所有子业务模块进行整合成为一个完整的 App，主要体现在 Splash 页面、首页等，这个时候的应用更像是一个空架子，而很少有具体的业务实现。</p></li></ul><p>除此之外还有一个很重要的 DI 控制模块，这一层主要负责将具体接口的实现注入，这一层本身可以脱离主项目存在，但介于现在 Android 还没有一个较为满意的依赖注入框架，暂时我们先放在应用层，后面计划封装成一个单独的框架，就可以实现类似 Sprint 用配置文件的方式来控制依赖注入，然后通过使用 AOP 的方式进行初始化，这样整个依赖注入控制模块就和主项目没有任何直接的关联了。</p><p>除了在每层的角色划分外，还有一个 Common Utils 模块，这是一个并列与所有层级存在的一个模块，可以被任何一个模块引用。</p><h3 id="接口纵向分层和横向分类"><a href="#接口纵向分层和横向分类" class="headerlink" title="接口纵向分层和横向分类"></a>接口纵向分层和横向分类</h3><h4 id="纵向分层"><a href="#纵向分层" class="headerlink" title="纵向分层"></a>纵向分层</h4><p>在多线开发过程中，针对某个功能模块抽象出来的接口，要么不能满足所有产线的需求，要么会定义一些其他线不需要的接口。所以针对这样的过程我们考虑了接口纵向分层的概念，如果在一个相对小的合作团队中，可以不考虑这个问题。比如在网络请求这个功能模块的封装，我们将接口层分为 Common 接口层和业务接口层。</p><ul><li><p>Common 接口层只定义通用的网络请求的接口，不包含任何产线对网络请求模块额外定义的功能。会有一个通用的网络实现库区实现这一层的接口，基于 Volley、OkHttp 或者 Android-Async-Http 去实现接口。</p></li><li><p>业务接口层是每个产线针对自己的业务需求对网络请求功能进行的特殊定义，如对返回状态码的处理、API 层级的业务缓存和网络加密验证等。这种业务有的产线需要，有的产线不需要，即使都需要也可能出现需要定义的接口千差万别，所以每个产线单独定义这一层的接口，当然这层接口的实现也是由产线自己封装实现。</p></li></ul><p><img src="http://images.notend.cn/2016-12-20-14-58-10.png" alt=""></p><h4 id="横向分类"><a href="#横向分类" class="headerlink" title="横向分类"></a>横向分类</h4><p>关于接口层里面不同功能模块的接口以怎样的形式组合和依赖，有两种方式，一种是在同一接口层的所有接口都放在一个库里面，所有需要用到任何接口的部分，都依赖这个接口库；还有一种是将接口和具体实现放在一个项目一起维护，只是这个模块提供两个依赖库：接口库和实现库。这两种实现方案各有利弊。</p><p>第一种方案方便使用方的理解和使用，对于使用方只需要知道接口这个库，其他不需要知道，当有接口不满足的话，直接提需求就可以了。弊端是在任何一个模块的接口发生变化，都需要更新整个接口层，不过好在 Gradle 通过依赖合并的方式解决了这个问题，你只需要在你需要升级接口的地方升级，其他地方如果跟这次接口升级没有关系的话，依然可以使用老的版本。</p><p>第二种方案比较方便于模块维护人员的维护，当你需要升级接口时能够在一个项目里面同时把接口层和实现层同时升级掉。第二种方案的缺陷也是很明显的，这样在接口层之前形成的依赖关系，又会和之前模块之间形成的依赖关系一样复杂，对于使用方还是要去理解复杂的依赖关系。</p><p>结合这两种方案的优缺点，我们选择一个相对折中的方案，在同一层级的接口上进行横向分类，这样将整个接口层分成几个大的接口库去维护，这样能够有效降低一些模块变化对整个接口库版本的升级的影响，同时也可以减少一个接口库同时维护人员的数量，如果分配合理的话，甚至可以每个接口库和对应的实现层都是一个人维护，同样降低维护人员的成本。当然如果你们的接口本身就很少，就不用为这个问题烦恼了。</p><h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><p>除了通过接口实现模块间的通讯方式，我们还设计了一套内部通讯协议，用于在应用内部消息通讯。对于一些易变的、灵活的、简单的通讯，可以直接通过发送消息的方式进行通讯。在任何一个想要接受到消息的地方，只要监听对应的消息就可以了，不管你是在主线程或者子线程。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>我们是从解决Android 6.0 的权限处理问题引入 AOP 技术的，为了在不影响之前的代码的情况下，我们通过横向切入的方式解决了这个问题。</p><p>除了解决类似这种问题以外，我们使用 AOP 技术来实现只在 Debug 包才需要的功能，如一些测试的辅助工具、快速调试工具（调试板）等。这些功能只会出现在 Debug 包中，又不会影响到主项目的代码。</p><h2 id="实施过程"><a href="#实施过程" class="headerlink" title="实施过程"></a>实施过程</h2><p>我们将整个重构融合到每个迭代中，逐步实现一次架构的大调整，为了保证业务正常的进行，同时进行平稳的重构，我们把整个实施过程进行了细致的划分，这里大概总结下我们的实施过程。</p><h3 id="从底层开始着手"><a href="#从底层开始着手" class="headerlink" title="从底层开始着手"></a>从底层开始着手</h3><ul><li>将 Common Utils 和 SDK 扩展层逐步独立到单独的库。</li><li>将 Base View 逐步独立到单独的库。</li><li>将 Base Class 逐步独立到单独的库。</li></ul><h3 id="抽离功能模块"><a href="#抽离功能模块" class="headerlink" title="抽离功能模块"></a>抽离功能模块</h3><ul><li>将功能模块的接口逐步定义完成，并在对应的库提供相应的实现。</li><li>在主项目完成功能模块的依赖注入。</li><li>将对于功能模块的调用逐步换成接口的调用方式。</li><li>去掉之前的依赖关系。</li></ul><h3 id="抽离公共视图模块"><a href="#抽离公共视图模块" class="headerlink" title="抽离公共视图模块"></a>抽离公共视图模块</h3><p>在抽取公共试图的时候需要区分哪些是属于哪些是公共试图，哪些是具体业务定制的试图。将属于公共的部分逐步抽离到公共试图库。需要说明的是，公共试图模块不一定是一个单独的库，可以根据需要拆分成不同的库，只要保证整个都在试图模块这一范畴就可以了。</p><h3 id="抽离公共业务模块"><a href="#抽离公共业务模块" class="headerlink" title="抽离公共业务模块"></a>抽离公共业务模块</h3><ul><li>定义公共业务模块的接口，并提供实现。</li><li>完成依赖注入和调用替换。</li><li>依赖关系解除。</li></ul><p>在抽离业务模块的时候，当业务模块提供了试图直接给外部使用，个人建议是将试图部分和具体的业务实现拆分到不同的 Model。试图属于试图模块，通过调用接口的方式实现内部逻辑。主项目或者其他模块需要使用该试图的时候，可以直接依赖（业务模块可以直接依赖任何试图组件）。</p><h3 id="抽离产线业务模块"><a href="#抽离产线业务模块" class="headerlink" title="抽离产线业务模块"></a>抽离产线业务模块</h3><p>和抽离公共业务模块的步骤类似。</p><h3 id="DI-控制框架封装"><a href="#DI-控制框架封装" class="headerlink" title="DI 控制框架封装"></a>DI 控制框架封装</h3><p>实现 DI 的配置化框架。</p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>在重构过程中，还会碰到平时写代码由于不注意导致的隐形的坑，比如我们碰到过一个在库里面存在类型强转导致的问题。这种问题不可避免，但是如果你在平时写代码时比较遵守代码规范，这种问题应该会相对较少。</p><ul><li>Kotlin 试图文件目录迁移，Layout 不会修改对应的类名，需要手工确认，这个时候可以编写一些脚本才做这个事前。</li><li>目录调整后，proguard 过滤文件相应的调整。</li><li>如果之前一些模块在主项目已经以单独的包存在的时候，在抽离到单独的库的时候，把之前关于这个目录的 git 记录保留。</li><li>当新增一个子模块的时候，可以先以代码的方式成为主项目的 Model 依赖，在相对稳定以后再提供 Maven 库依赖。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于大的架构重构，其实我们一直很谨慎的。我们的原则是将重构融合在每次迭代中，逐步优化代码的结构。这次针对整个应用的架构的调整的背景是公司移动开发部门的人数和项目越来越多，当初设计的移动端的架构让项目的依赖关系越来越复杂，维护成本也越来越高。刚好赶上公司产品的特别需求，我们决
      
    
    </summary>
    
    
      <category term="Android" scheme="http://ohmerhe.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Library 不支持调试模式，不能忍</title>
    <link href="http://ohmerhe.com/2016/08/30/android_library_debug/"/>
    <id>http://ohmerhe.com/2016/08/30/android_library_debug/</id>
    <published>2016-08-30T09:28:49.000Z</published>
    <updated>2019-01-02T02:38:27.096Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Android, Gradle</p><p>在 Android 开发过程中，<code>BuildConfig.Debug</code> 这个变量用来判断当前运行环境是不是支持调试模式。我们常常利用这个变量的判断在开发或者测试包中做一些代码追踪、测试工具开启、调试信息等工作。不过在 Android 依赖库中默认编译出来的包并不会像编译应用一样默认会自动生成 release 和 debug 两种包，它只会默认生成 release 一个版本的包，可以参考<a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Referencing-a-Library" target="_blank" rel="noopener">这里</a>。在 release 版本的包里面，除非你有做过改动，不然默认 debuggable 这个值是 false。</p><p>常见的依赖库的使用方式有两种，一种是把依赖库的作为一个模块和主项目一起编译，也就是文件依赖；另一种是使用 aar 的方式引用，下面分别针对两种不同的提供对应得解决方案。</p><h2 id="文件依赖方式"><a href="#文件依赖方式" class="headerlink" title="文件依赖方式"></a>文件依赖方式</h2><p>其实 <a href="https://code.google.com/p/android/issues/detail?id=52962" target="_blank" rel="noopener">这个问题</a> 早在 2013 年就有人在 Google Group 上提出来。根据 <a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Library-Publication" target="_blank" rel="noopener">官方文档</a>，我们可以通过控制 <code>publishNonDefault</code> 这个变量的配置来使得依赖库在编译的时候默认生成所有变种的包，而不是仅仅生成 release 一种。</p><p>在依赖项目中添加这个配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    publishNonDefault <span class="literal">true</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样在编译完成后，默认情况下我们可以在输出目录看到两个 aar 文件（之前只有一个）。然后在项目中声明依赖的时候，区分不同的编译类型进行依赖：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    debugCompile project(<span class="string">path:</span> <span class="string">':myLocalLibrary'</span>, <span class="string">configuration:</span> <span class="string">'debug'</span>)</div><div class="line">    releaseCompile project(<span class="string">path:</span> <span class="string">':myLocalLibrary'</span>, <span class="string">configuration:</span> <span class="string">'release'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样在调试应用的过程中会使用依赖库的 debug 版本，而在正式发布应用的时候就会用 release 版本。</p><h2 id="AAR-依赖方式"><a href="#AAR-依赖方式" class="headerlink" title="AAR 依赖方式"></a>AAR 依赖方式</h2><p>Library 还有一种更为常见的依赖方式——aar 依赖。当然如果是正式发布的依赖库，不支持 debug 功能是很合理并且应该鼓励的。但是，不能忽视的是在我们开发过程频繁使用的 snapshot 版本，这是开发过程中的测试版本，在这个版本中支持调试功能即合理也很有必要。</p><p>在前面官方文档中，我们发现还有一个配置信息可以利用 <code>defaultPublishConfig</code>。这个变量用于指定使用哪个变种的包作为默认编译的版本。默认这个值是 <code>release</code>。你可以在项目的配置添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    defaultPublishConfig &quot;debug&quot;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>这个配置项后面的值是编译变种的全称，如果对于变种（variants）的概念不是很熟悉的话，可以回去再看看 Google 的 <a href="https://developer.android.com/studio/build/build-variants.html" target="_blank" rel="noopener">定义</a>。</p></blockquote><blockquote><p>如果没有定义针对变种做过配置的话，默认支持 <code>release</code> 和 <code>debug</code> 两种，这是根据这两种默认编译类型自动生成的。</p></blockquote><p>这里有一个明显的 bug，必须在发布正式包和 snapshot 包的时候手动切换配置项的值。在我的项目中，我在发布 aar 包的时候，是通过在 <code>gradle.properties</code> 这个文件添加 <code>isRelease</code> 这个变量来区分的。当这个值是 <code>true</code> 的时候则会发布正式包，反之则发布 snapshot 版本。于是我也利用这个值来控制这个配置项的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">defaultPublishConfig System.properties[&apos;isRelease&apos;].toBoolean() ? &quot;release&quot; : &quot;debug&quot;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>在 Groovy 中看到熟悉的三目运算好亲切啊，想到在 Kotlin 中没有三目运算就心塞。</p></blockquote><p>这样在发布依赖包时，就能自动实现在 snapshot 包支持调试功能，而不影响正式包。</p><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>如果不使用这种方式，在代码层面想办法绕过这个限制也不是特别困难。比如我们可以在依赖库中提供接口，然后在项目中将是否支持 Debug 状态的判断注入到依赖库中，从而实现依赖库和主项目之间的 Debug 状态保持一致。</p><p>虽然这种方案也可以解决问题，但是我个人不是很推荐。这种配置方式本身和依赖库的功能没有关联性，而且无形增加了依赖库的接入成本。</p><h3 id="手动修改"><a href="#手动修改" class="headerlink" title="手动修改"></a>手动修改</h3><p>还有一种方案，是在依赖库编译完成之后，通过判断当前编译变种的类型，手动去修改 <code>BuildConfig</code> 里面的值。这种方案无形增加了解决问题的复杂度，和前面利用官方配置项没有本质区别。根据这种方案的提出的时间，我猜测这应该是在官方支持如上描述的配置方案之前的方案。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://tools.android.com/tech-docs/new-build-system/user-guide" target="_blank" rel="noopener">Gradle Plugin User Guide</a></li><li><a href="https://guides.codepath.com/android/Building-your-own-Android-library" target="_blank" rel="noopener">Building your own Android library</a></li><li><a href="https://code.google.com/p/android/issues/detail?id=52962" target="_blank" rel="noopener">Issue 52962:    Gradle plugin does not propagate debug/release to dependencies</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tags: Android, Gradle&lt;/p&gt;
&lt;p&gt;在 Android 开发过程中，&lt;code&gt;BuildConfig.Debug&lt;/code&gt; 这个变量用来判断当前运行环境是不是支持调试模式。我们常常利用这个变量的判断在开发或者测试包中做一些代码追踪、测试工具开启、
      
    
    </summary>
    
    
      <category term="Android" scheme="http://ohmerhe.com/tags/Android/"/>
    
      <category term="Gradle" scheme="http://ohmerhe.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin：The Good, The Bad, and The Ugly(译)</title>
    <link href="http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/"/>
    <id>http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/</id>
    <published>2016-08-27T08:59:00.000Z</published>
    <updated>2019-01-02T02:38:31.230Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin, Android</p><p>在我的 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="noopener">上一篇文章</a>, 谈到了关于转换 Java 到 Kotlin 代码和我喜欢的一些库。现在，我想要谈谈关于 Kotlin 这门语言本身的想法，还有它和 Java 交互的方式。</p><h2 id="The-Good"><a href="#The-Good" class="headerlink" title="The Good"></a>The Good</h2><p>Kotlin 有许多让人喜欢的理由。像 <code>null safety</code>、<code>property access</code> 和 <code>unchecked exceptions</code> 类似这些明显的特性在 <a href="https://blog.jetbrains.com/kotlin/2016/01/kotlin-digest-2015/" target="_blank" rel="noopener">publications</a> 都有描述，我就不重复了。我只讲一些我真正喜欢但很少被提到的特性。</p><h3 id="Automatic-conversion-of-Java-to-Kotlin"><a href="#Automatic-conversion-of-Java-to-Kotlin" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>JetBrains 在 IntelliJ 中集成了 <code>Java to Kotlin converter</code> 为我们节约了大量的时间。虽然它还不是很完美，但是它让你不用再重复输入。要是没有它，你将要花费大量的时间从 Java 代码转换成 Kotlin。</p><h3 id="lateinit-Delegates-notNull-and-lazy"><a href="#lateinit-Delegates-notNull-and-lazy" class="headerlink" title="lateinit, Delegates.notNull and lazy"></a>lateinit, Delegates.notNull and lazy</h3><p>Kotlin 的 <code>null safety</code> 非常好，但是由于在 Android 的 Activity 生命周期的设计，你常常不得不在 <em>onCreate</em> 这样的回调中初始化一个变量，而不是在类的构造函数中。假设你有一个属性需要定义，你肯定想要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val name: String</div></pre></td></tr></table></figure><p>如果你必须在 <code>onCreate</code> 中初始化这个属性，就不能用 <code>val</code> 定义，而必须使用 <code>var</code>。但是这样你必须在定义的时候为该属性提供一个值进行初始化，或者将它定义为可空类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name: String? = null</div></pre></td></tr></table></figure><p>这样的确有效，但是当你每次使用它的时候都要进行空检查。虽然 Korlin 提供了友好的的空断言，但是在实践中即使你知道你的属性不会为空，你也不愿意到处使用 <code>!!</code>。庆幸的是，Kotlin 提供了更好的方式：<a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties" target="_blank" rel="noopener"><em>lateinit</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="noopener"><em>Delegates.notNull</em></a>。任何一个都能可以让你在不初始化的情况下定义一个非空类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lateinit var name: String</div><div class="line">var age: Int by Delegates.notNull&lt;Int&gt;()</div></pre></td></tr></table></figure><p>这两种方式中，当你尝试在初始化之前访问该属性都会抛出异常。除了<code>lateinit</code> 不能用于基础类型的定义，这两种方法没有什么大的差别。</p><p>你还有第三种选择就是使用 <code>lazy</code> 委托。如果一个属性能够利用其他属性或方法获得数据进行初始化，那么 <code>lazy</code> 会是一个很好的选择。类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val imm: InputMethodManager by lazy &#123; </div><div class="line">    getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面块里面的代码在第一次读取之前并不会执行，执行的结果会被保存起来以供后面使用，所以后面的代码块只会被执行一次。</p><h3 id="Functional-collection-extensions"><a href="#Functional-collection-extensions" class="headerlink" title="Functional collection extensions"></a>Functional collection extensions</h3><p>Kotlin 提供为集合和迭代类提供了大量的函数式 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html#functions" target="_blank" rel="noopener">扩展方法</a>。像 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/any.html" target="_blank" rel="noopener"><em>any</em></a>、 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="noopener"><em>joinToString</em></a> 和 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/associate.html" target="_blank" rel="noopener"><em>associate</em></a> 的方法能够帮助节约大量的时间，不用像 Java 里面一样手工编写 <em>for</em> 循环去实现。</p><p>Kotlin 还提供了大量的函数式集合操作的懒加载模式，在这种模式下载每个操作执行之前并不会进行集合的拷贝，但是在我的接受范围内，发现懒加载和即刻加载在性能上并没有什么大的差别。</p><h3 id="Named-and-default-function-arguments"><a href="#Named-and-default-function-arguments" class="headerlink" title="Named and default function arguments"></a>Named and default function arguments</h3><p><a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="noopener">命名参数</a> 和 <a href="https://kotlinlang.org/docs/reference/functions.html#named-arguments" target="_blank" rel="noopener">默认参数</a> 是非常基础的，但它们让你不再需要重载方法，并且也替代了 Builder 模式的一种使用场景。</p><p>根据具体使用场景，你甚至可以在依赖注入中将生产依赖作为默认参数，然后在测试的时候传入模拟的数据。</p><p>例如，你在 <code>presenter</code> 中需要一些全局状态，你可以这样定义构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Presenter(</div><div class="line">        val okhttp: OkHttp = productionOkHttp(),</div><div class="line">        val picasso: Picasso = productionPicassoInstance()</div><div class="line">) &#123;...&#125;</div></pre></td></tr></table></figure><p>这样，你就你可以 <code>UI</code> 代码中创建 <code>presenter</code> 实例的时候不传递任何参数，但是在测试的时候可以传递模拟的实例作为参数。完整的依赖注入框架会更加强大，但这是一个一些简单语言构造的很好的例子。</p><h2 id="The-Bad"><a href="#The-Bad" class="headerlink" title="The Bad"></a>The Bad</h2><p>尽管 Kotlin 非常棒，但是它并不完美。我列举了一下我不喜欢的部分。</p><h3 id="No-namespaces"><a href="#No-namespaces" class="headerlink" title="No namespaces"></a>No namespaces</h3><p>Kotlin 允许你在文件中定义顶级的函数和属性。这是一个非常棒的特性，但是这会带来所有从 Kotlin 引用的顶级声明无法区分的困扰。有时，这让我们在读代码的时候很难快速确定用的是哪一个函数。</p><p>例如，你定义这样一个顶级函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun foo() &#123;...&#125;</div></pre></td></tr></table></figure><p>你可以通过 <code>foo()</code> 调用。如果你在不同的包里面也存在同样的方法，在调用侧不能明显区分出是调用的哪个方法。你可以通过在前面添加包名的方式去调用，但是如果 Java 约定的包名很深，似乎不太好。</p><p>一种近似的解决方案是使用单例的 <code>object</code> 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object FooActions &#123;</div><div class="line">    fun foo() &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样你在 Kotlin 中可以通过 <code>FooActions.foo()</code> 调用，但是在 Java 代码中就不是那么友好了。在 Java 中你必须要这样 <code>FooActions.INSTANCE.foo()</code> 这样调用，这看起来并不完美。你可以使用 <code>@JvmStatic</code> 去注解你的方法从而省掉 <code>INSTANCE</code>，这是你能做到的最好结果。这并不是什么大不了的事，但是如果 Kotlin 能够提供命名空间的话，能省不少事。</p><h3 id="No-static-modifier"><a href="#No-static-modifier" class="headerlink" title="No static modifier"></a>No static modifier</h3><p>无独有偶，Kotlin 提供为静态函数和属性提供了一个和 Java 不一样的处理方式。并不是说有多烂，只是觉得让代码变得不干净而且没有必要。例如，在 Android 的 <code>View</code> 类中定义的静态属性 <code>View.VISIBLE</code> 和静态函数 <code>View.inflate</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class View &#123;</div><div class="line">    public static final int VISIBLE = 0x00000000;</div><div class="line">    public static final int INVISIBLE = 0x00000004;</div><div class="line">    public static View inflate(Context context, int resource) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个定义是简单的。然而，在 Kotlin 代码中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class View &#123;</div><div class="line">    companion object &#123;</div><div class="line">        @JvmField </div><div class="line">        val VISIBLE: Int = 0x00000000</div><div class="line">        @JvmField </div><div class="line">        val INVISIBLE: Int = 0x00000004</div><div class="line">        @JvmStatic</div><div class="line">        fun inflate(context: Context, resource: Int) &#123;...&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>尽管 Kotlin 的版本并没有那么恐怖，但是它的复杂程度超过了我对这门语言的预期。如果把注解去掉，那么你在 Java 代码中不得不使用这样可怕的语法去调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// With annotations:</div><div class="line">View.VISIBLE;</div><div class="line">//Without annotations:</div><div class="line">View.Companion.getVISIBLE();</div></pre></td></tr></table></figure><p>没有更好的方式去创建静态函数和属性让我感觉很奇怪。我知道 <code>companion objects</code> 是真正的对象并且能够用来实现接口，但是这并不能足够说明能完全替代普通的静态声明。</p><h3 id="Automatic-conversion-of-Java-to-Kotlin-1"><a href="#Automatic-conversion-of-Java-to-Kotlin-1" class="headerlink" title="Automatic conversion of Java to Kotlin"></a>Automatic conversion of Java to Kotlin</h3><p>在我的第一篇帖子里这是我列出来的我喜欢 Kotlin 的愿意之一，并且它很好用。但是正由于它在 80% 的时候都运行的很好，它在一些场景的失败实在令人沮丧。</p><p>Java 文档经常错位，特别是在段落横跨了好几行的时候。静态域和方法被转换成 <code>companion object</code>，除非你手动添加为他们分别添加 <code>@JvmField</code> 和 <code>@JvmStatic</code> ，你之前 Java 调用代码不在有效而出错。</p><p>由于 Kotlin 团队花了大量的时间在转换代码上，我相信这些问题一定会被修复的，因此我对这些问题保持乐观。</p><h3 id="Required-property-accessor-syntax"><a href="#Required-property-accessor-syntax" class="headerlink" title="Required property accessor syntax"></a>Required property accessor syntax</h3><p>Kotlin 提供一个很棒的语法糖叫做「属性访问语法」，它让你可以像访问 Kotlin 属性一样访问 <code>JavaBeans</code> 类型的 <code>getters</code> 和 <code>setters</code> 方法。例如，你可以这样 <code>activity.context</code> 调用 <code>Activity.getContext()</code>，而不用写整个方法名。如果你在 Kotlin 使用传统的方式调用，lint 会给你一个警告告诉你使用「属性调用语法」。</p><p>这是一个很好的特性，但是有时候我的方法名以 <code>get</code> 开始，但是并不想使用「属性调用语法」。一个很常见的例子就是 Java 的原子类。如果你有一个变量 <code>val i = AtomicInteger()</code>，你可能想通过 <code>i.getAndIncrement()</code> 调用。但是 Kotlin 会想让你用 <code>i.andIncrement</code> 这种方式调用。这明显是画蛇添足。</p><p>你可以在每个调用的地方加上 <code>@Suppress(“UsePropertyAccessSyntax”)</code>，但很丑。如果你可以为这个函数添加一个注解告诉 linter 不要把它当做一个属性会更好。</p><h3 id="Method-count"><a href="#Method-count" class="headerlink" title="Method count"></a>Method count</h3><p>用 Kotlin 写代码肯定会减少你项目中的代码行数。但是它也会提高你的代码在编译以后的方法数。有很多原因导致这一点，但是其中一个主要原因就是 Kotlin 属性的实现方式。</p><p>和 Java 不一样，Kotlin 没有提供单独定义域的方式。你必须使用 <code>val</code> 或者 <code>var</code> 来声明变量。这样有一个好处，就是你可以随意为一个属性添加 <code>get</code> 或 <code>set</code> 方法而不会破坏其他地方对该属性引用的代码。这个特性省去了像 Java 一样定义 <code>getters</code> 和 <code>setters</code> 方法。</p><p>尽管如此，这个特性需要一定的成本。每一个公开的 <code>val</code> 变量都会导致 Kotlin 生成一个「支持域」和一个能被 Java 调用的 <code>getter</code> 方法。每一个公开的 <code>var</code> 变量都会生成 <code>getter</code> 和 <code>setter</code> 方法。庆幸的是，私有属性的 <code>getters</code> 和 <code>setters</code> 会生成域而不是生成方法。如果你之前的 Java 代码中定义了大量的公开域（这在定义常量的时候很常见），你会惊奇的发现方法大幅上升。</p><p>如果你的 Android 应用快接近方法数限制了，我建议你为不需要自定义 <code>getter</code> 方法的常量加上 <code>@JvmField</code> 注解。这样会阻止  <code>getters</code> 方法的生成，从而减少你的方法数。「更新：Kirill Rakhman 在评论中指出，你可以使用 <code>const</code> 修饰符替代 </p><p>不过其实没有那么糟。就像我在 <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6" target="_blank" rel="noopener">converting an app to 100% Kotlin</a> 文章里讨论过的，Kotlin 的标准库非常小，并且能够替代 Java 的许多常用库，这些库通常都更大，现在你再也不需要他们了。多亏了 Kotlin 的标准库，在从 Java 全部转换到 Kotlin 以后方法数反而减少了。只要你控制不会出现大范围的方法数提升，就不会有什么问题。</p><h2 id="The-Ugly"><a href="#The-Ugly" class="headerlink" title="The Ugly"></a>The Ugly</h2><p>最后，Kotlin 有两个设计我不是很认同，而且我不期望这个在未来会有什么改变。</p><h3 id="SAM-conversion-and-Unit-returning-lambdas"><a href="#SAM-conversion-and-Unit-returning-lambdas" class="headerlink" title="SAM conversion and Unit returning lambdas"></a>SAM conversion and Unit returning lambdas</h3><p>这真是一个莫名其妙的设计。</p><p>可以嵌入 lambda 表达式是 Kotlin 最好的特性之一。如果有一个 Java 函数，它只有一个 SAM 接口（只有一个抽象方法的接口）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void registerCallback(View.OnClickListener r)</div></pre></td></tr></table></figure><p>无论是 Java 还是 Kotlin，你都可以传递一个普通的 lambda 表达式去调用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Java</div><div class="line">registerCallback(() -&gt; &#123; /** do stuff */ &#125;)</div><div class="line">//Kotlin</div><div class="line">registerCallback &#123; /** do stuff */ &#125;</div></pre></td></tr></table></figure><p>这的确很棒。但当你尝试去用 Kotlin 去定义类似的方法是莫名的困难。从 Java 测调用没有什么不同，但是当从 Kotlin 调用时需要明确指定类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fun registerCallback(r: View.OnClickListener)</div><div class="line">// Kotlin. Note that parenthesis are required now.</div><div class="line">registerCallback(View.OnClickListener &#123; /** do stuff */ &#125;)</div></pre></td></tr></table></figure><p>不得不说这很烦人，特别是当你从 Java 代码转换到 Kotlin 从而导致 Kotlin 代码不能再正常运行的时候。</p><p>常见的方式是用函数类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fun registerCallback(r: () -&gt; Unit)</div></pre></td></tr></table></figure><p> 这样用 Kotlin 调用起来会很方便，但是由于所有的 Kotlin 函数都需要一个返回值，这导致用 Java 调用该函数的时候变得很糟。你不得不显式地从 Java 表达式返回 <code>Unit</code>，这导致 lambda 表达式不可用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> registerCallback(() -&gt; &#123;</div><div class="line">    /** do stuff */</div><div class="line">    return Unit.INSTANCE;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>如果你在用 Kotlin 写库的话，根本找不到一个好的方式去实现一个高阶函数同时让 Java 和 Kotlin 都能方便的调用。在我的 <a href="https://github.com/ajalt/flexadapter" target="_blank" rel="noopener">FlexAdapter</a> 库里面，我尝试为为每个方法重载 <code>SAM interface</code> 或者 Kotlin 函数类型的参数。这样无论用这两种的哪种语言调用都很方便，但是库的 API 变得不简洁。</p><p>希望 Kotlin 的设计者们能够改变他们的想法在将来允许 <code>SAM</code> 转化成 Kotlin 的函数定义，但是我并不抱什么希望。</p><h3 id="Closed-by-default"><a href="#Closed-by-default" class="headerlink" title="Closed by default"></a>Closed by default</h3><p>到目前为止我说的所有关于 Kotlin 的缺点基本都是小的语法细节上的不简洁，并不是什么大事。但是，有一个设计在将来有可能导致巨大的痛苦：所有的类和方法默认都是封闭的。这种做法是被 <code>Effective Java</code> 里所推崇的，理论上听起来也很有道理，但对于任何一个需要使用一个有缺陷的第三方库的人来说都是一个坏的选择。</p><blockquote><p>把所有的叶类都设置成静态的。毕竟你在完成这样一个项目——没有人能够通过扩展你的类的方式来完善你的工作成果。或许是由于安全原因——毕竟，<code>java.lang.String</code> 是 <code>final</code> 不就是由于这个原因吗？如果你项目的其他的成员向你抱怨，就告诉他们这样能提高执行效率——<a href="http://www.mindprod.com/jgloss/unmaindesign.html" target="_blank" rel="noopener"><em>Roedy Green, How to Write Unmaintainable Code</em></a></p></blockquote><p>Kotlin 的文档里面的确有文章尝试去抵制这一决定，所以我把他们说的三个理由列出来。</p><h3 id="“Best-practices-say-that-you-should-not-allow-these-hacks-anyway”"><a href="#“Best-practices-say-that-you-should-not-allow-these-hacks-anyway”" class="headerlink" title="“Best practices say that you should not allow these hacks anyway”"></a>“Best practices say that you should not allow these hacks anyway”</h3><p>关于对继承封闭的论据基本是围绕「Fragile Base Class Problem」展开，它认为如果允许在你的库的基础上继承出子类，他们可能改变代码运行的方式从而导致一些 bug。然而这只是一种可能性，会导致库运行异常从而导致 bug 的方式实在太多了。如果你重写一个类的功能，很明显你应该为破坏代码的运行负责。</p><p>我之所以用「很明显」是因为重写一个库的功能是很明确的该有使用方自己负责。我已经辅导计算机科学学生很多年了，他们会范所有你能想象到的错误，但是他们从不会因为重载一个方法导致的破坏感到奇怪。实在有太多不经意的方式会导致对依赖库使用的破坏，例如你传递的参数类型是对的但单位却传错了，或者你忘了调用一个必须调用的方法。</p><p>我欣赏那种减少代码被破坏可能性的编码方式，把类设置成不可变的的确能达到效果。但可以确定的是所有依赖库一定不是完整的或者是存在缺陷的，你又不可避免的要使用这些依赖库。为了修改一个封闭类，人们常常会使用一些 hack 的方法，这经常会仅仅是重写一两个类或者方法带来的 bug 更多。如果你不相信我说的话，这里有一个活生生的例子，如果你是一个 Android 开发者的话，你应该印象深刻：</p><p>AppCompat 23.2.0 终于把 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="noopener">VectorDrawables</a> 加到 support 包里了。由于可以帮助减少 APK 的体积和内存的占用，要不是它有一个 bug <a href="https://code.google.com/p/android/issues/detail?id=205236" target="_blank" rel="noopener">会导致在 Activity 里面导致内存泄露</a><br>，本应该收到广泛欢迎。这个支持包在 <a href="https://plus.google.com/+AndroidDevelopers/posts/iTDmFiGrVne" target="_blank" rel="noopener">几周后被移除</a>。</p><p>内存泄露是怎么导致的呢？为了 <a href="https://medium.com/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88" target="_blank" rel="noopener">提高 VectorDrawable 填充性能</a>，这个支持包的作者们需要改进 <code>Context.getDrawable</code> 的实现。但是这个方法是不可变的（final），所以他们不得不为每一个视图创建一份 <code>Resources wrapper</code> 的拷贝来处理 <em>VectorDrawables</em>。且不说这带来了大量的工作，这也导致大量的 <code>wrapped Resources</code> 变得不同步和为了复制产生的大量内存开销。如果那个方法不是不可变的，他们就不会这样胡搞了。</p><h3 id="“People-successfully-use-other-languages-C-C-that-have-similar-approach”"><a href="#“People-successfully-use-other-languages-C-C-that-have-similar-approach”" class="headerlink" title="“People successfully use other languages (C++, C#) that have similar approach”"></a>“People successfully use other languages (C++, C#) that have similar approach”</h3><p>人们在 Python 这样的语言可以在任何时候做任何修改。Python 也有像 <code>_asdict</code> 这样「非公有」不会在文档里描述的方法。它也有像 <code>__intern</code> 这样的 <a href="https://zh.wikipedia.org/wiki/Visual_C%2B%2B%E5%90%8D%E5%AD%97%E4%BF%AE%E9%A5%B0" target="_blank" rel="noopener">name mangled</a> 的函数，很难被发现。你可以自由的用 monkey-patch 或者重写任何一个你想重写的方法，Python 并不禁止这样做。</p><p>在我五年全职开发 Python 的期间，我从没有想过谁会通过重写方法破坏我的代码。我能想象在大多数情况下，用正确安全的方法去改变一个私有方法比由于 Python 的禁止而不得不重新实现一个同样的功能更加节约时间。</p><p>我并不是说要盲目地把每个类的实现都要改一遍，但是没有理由当我想这么做的时候却做不了。在 Python 社区里面有一句俗语 “We’re all consenting adults here”。你想对我的类做任何修改都可以。</p><h3 id="“If-people-really-want-to-hack-there-still-are-ways-you-can-always-write-your-hack-in-Java-and-call-it-from-Kotlin-see-Java-Interop-and-Aspect-frameworks-always-work-for-these-purposes”"><a href="#“If-people-really-want-to-hack-there-still-are-ways-you-can-always-write-your-hack-in-Java-and-call-it-from-Kotlin-see-Java-Interop-and-Aspect-frameworks-always-work-for-these-purposes”" class="headerlink" title="“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”"></a>“If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (see Java Interop), and Aspect frameworks always work for these purposes”</h3><p>这真是一个荒诞的论点。即使是用 Java 如果你不用很难令人接受的反射的话，你依然不能重写封闭的 Kotlin 函数，所以这个论调无足轻重。</p><p>不能对依赖库进行扩展意味着想要添加任何新的特性和修改 bug 都很难。现实中，大多数库都需要使用一些黑客的手段。这就是现实，而且不会改变。任何库的作者都不能预测所有用户可能碰到的场景。所有的类都是不可变的只能让库的使用者实现库本身没有的功能的时候变得更加困难。相对于 Kotlin 其他语言特性的便利性，这个设计实在是太令人费解了。</p><p>如果你在编写一个 Kotlin 的依赖库，请把你所有的公开方法都设置成开放的。这会让你的用户更加方便。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Kotlin 是一门非常棒的语言。它比 Java 简洁多了，它还有一个非常优秀的标准库，有了这个标准库你就可以将大量为了维持 Java 勉强可用下去的库都删掉了。多亏了代码自动转换功能，你可以很方便的把 Java 代码转换成 Koltin 代码，并且这个功能会越来越完善。如果你是一名 Android 开发者，你真应该去试一试。</p><p>原文链接：<a href="http://ohmerhe.com/2016/08/27/kotlin_good_bad_bugly/">Kotlin：The Good, The Bad, and The Ugly(译)</a></p><p>英文原文：<a href="https://medium.com/keepsafe-engineering/kotlin-the-good-the-bad-and-the-ugly-bf5f09b87e6f#.s0t91g9xn" target="_blank" rel="noopener">Kotlin: The Good, The Bad, and The Ugly</a></p><p>欢迎大家投稿 <a href="http://www.jianshu.com/collection/ce44081f781f" target="_blank" rel="noopener">Kotlin Three</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><strong>[1]</strong> In the case of a <em>lateinit </em>property,<em>kotlin.UninitializedPropertyAccessException </em>will be thrown, where the<em>Delegates.notNull </em>will throw an <em>IllegalStateException</em>.</li><li><strong>[2]</strong> There are some details about <em>lateinit </em>that are worth noting, especially if you plan on accessing a <em>lateinit </em>property from Java code. First is that <em>lateinit</em>cannot be applied to primitive types such as <em>Int </em>or <em>Double</em>. The second is that a <em>lateinit </em>property is backed by a field with the same visibility as the property, and this field is visible from Java. Additionally, that backing field can be freely set to null from Java. If any of those are issues for your use case, <em>Delegates.notNull </em>may be a better choice.</li><li><strong>[3]</strong> The lazy <em>Sequence </em>operators can outperform the eager versions by up to 20%, but only once list sizes start growing very large. For lists under a megabyte or so in size, the lazy versions often perform the same or worse than the eager versions.</li><li><strong>[4]</strong> This is a bit of a simplification. Kotlin will only generate a backing field if you don’t define a get function, or if the defined get function doesn’t reference the implicit<em> field </em>identifier.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tags: Kotlin, Android&lt;/p&gt;
&lt;p&gt;在我的 &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dc
      
    
    </summary>
    
    
      <category term="Android" scheme="http://ohmerhe.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 一个扩展函数，从此丢掉 ViewHolder</title>
    <link href="http://ohmerhe.com/2016/08/02/kotlin_one_method_no_viewholder/"/>
    <id>http://ohmerhe.com/2016/08/02/kotlin_one_method_no_viewholder/</id>
    <published>2016-08-02T15:57:49.000Z</published>
    <updated>2019-01-02T02:38:31.248Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Android, Kotlin</p><h2 id="ViewHolder"><a href="#ViewHolder" class="headerlink" title="ViewHolder"></a>ViewHolder</h2><p>作为一名 Android 开发者，对 ViewHolder 应该再熟悉不过了。ViewHolder 一开始并不是 Android 原生提供的（现在已经是 RecycleView 的默认实现了），而是 Google 为了提高 ListView 的使用性能，为开发者提供的一种最佳实践，具体可以参考 <a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="noopener">ViewHolder</a>。</p><p>Google 提供的 ViewHolder 的标准实现如下，熟悉者可以直接跳到下个部分「ViewHolder变种」继续阅读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">  TextView text;</div><div class="line">  TextView timestamp;</div><div class="line">  ImageView icon;</div><div class="line">  ProgressBar progress;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 Item 第一次创建视图的时候，填充 ViewHolder 并且将其保存在视图中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ViewHolder holder = <span class="keyword">new</span> ViewHolder();</div><div class="line">holder.icon = (ImageView) convertView.findViewById(R.id.listitem_image);</div><div class="line">holder.text = (TextView) convertView.findViewById(R.id.listitem_text);</div><div class="line">holder.timestamp = (TextView) convertView.findViewById(R.id.listitem_timestamp);</div><div class="line">holder.progress = (ProgressBar) convertView.findViewById(R.id.progress_spinner);</div><div class="line">convertView.setTag(holder);</div></pre></td></tr></table></figure><p>在填充 Item 数据的时候，直接使用 Viewholder 对象的属性，这样可以减少在滚动 ListView 频繁调用 <code>findViewById()</code> 而导致的性能问题。</p><h2 id="ViewHolder变种"><a href="#ViewHolder变种" class="headerlink" title="ViewHolder变种"></a>ViewHolder变种</h2><p>Google 提供的 ViewHolder 的确能够提升 ListView 的使用效率，但是 ViewHolder 的实现相对繁琐，需要为每一种 Item 定义一个 ViewHolder，对代码书写和维护都是额外的开销。于是有人针对 ViewHolder 的实现做了一些优化，让 ViewHolder 写起来更方便。网上有很多种写法，我最认可的是下面的这种实现，简单优雅。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class ViewHolder &#123;    </div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)  </div><div class="line">    public static &lt;T extends View&gt; T get(View view, int id) &#123;  </div><div class="line">        SparseArray&lt;View&gt; viewHolder = (SparseArray&lt;View&gt;) view.getTag();  </div><div class="line">        if (viewHolder == null) &#123;  </div><div class="line">            viewHolder = new SparseArray&lt;View&gt;();  </div><div class="line">            view.setTag(viewHolder);  </div><div class="line">        &#125;  </div><div class="line">        View childView = viewHolder.get(id);  </div><div class="line">        if (childView == null) &#123;  </div><div class="line">            childView = view.findViewById(id);  </div><div class="line">            viewHolder.put(id, childView);  </div><div class="line">        &#125;  </div><div class="line">        return (T) childView;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里使用 <code>SparseArray</code> 映射每个视图 <code>id</code> 和对应的视图，并将其保存在视图中，这样既保证在滚动过程中频繁获取视图的效率，使用起来也极其方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ImageView bananaView = ViewHolder.get(convertView, R.id.banana);  </div><div class="line">TextView phoneView = ViewHolder.get(convertView, R.id.phone);  </div><div class="line">BananaPhone bananaPhone = getItem(position);  </div><div class="line">phoneView.setText(bananaPhone.getPhone());</div></pre></td></tr></table></figure><h2 id="Kotlin-扩展函数"><a href="#Kotlin-扩展函数" class="headerlink" title="Kotlin 扩展函数"></a>Kotlin 扩展函数</h2><p>这里Kotlin 实现 ViewHolder 的扩展函数和上面的变种使用的同一种思路，但得益于 Kotlin 语言提供的特性，实现和使用起来更加方便流畅，甚至都感觉不到 ViewHolder 这种特殊机制的存在。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View&gt;</span> View.<span class="title">findViewOften</span><span class="params">(viewId: <span class="type">Int</span>)</span></span>: T &#123;</div><div class="line">    <span class="keyword">var</span> viewHolder: SparseArray&lt;View&gt; = tag <span class="keyword">as</span>? SparseArray&lt;View&gt; ?: SparseArray()</div><div class="line">    tag = viewHolder</div><div class="line">    <span class="keyword">var</span> childView: View? = viewHolder.<span class="keyword">get</span>(viewId)</div><div class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == childView) &#123;</div><div class="line">        childView = findViewById(viewId)</div><div class="line">        viewHolder.put(viewId, childView)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> childView <span class="keyword">as</span> T</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里实现了一个 View 的扩展函数 <code>findViewOften(viewId: Int)</code> 意味着在需要频繁寻找一个视图的子视图的情况下使用，这样我们在 Item 中就可以这样写了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val subTitle: TextView = convertView.findViewOften(R.id.list_item_subtitle)</div><div class="line">subTitle.text = itemData.subTitle</div></pre></td></tr></table></figure><p>由于 Kotlin 提供类型推断功能，所以 <code>findViewOften</code> 的返回值不用手动转换或者手动指定泛型类型。</p><p>利用 Kotlin 的语言特性，为 View 扩展一个方法，从此再也不用繁琐的定义 Viewholder 了，使用的时候也是如此的顺畅，从此再也不必记得什么 ViewHolder 了。</p><p>PS: 该方法在 <a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="noopener">AndroidExtension</a> 已经提供封装，这个库里面还封装了一些其他方法，也蛮好用的，不过这个库还没有正式发布。</p><h2 id="RecycleView-的-ViewHolder"><a href="#RecycleView-的-ViewHolder" class="headerlink" title="RecycleView 的 ViewHolder"></a>RecycleView 的 ViewHolder</h2><p>最后，不得不提一下在 RecycleView 应该怎么办，因为在 RecycleView 的机制里面，在创建 Item 的 View 的时候，必须创建一个 RecyclerView.ViewHolder 并且返回。对于我们上面那么完美的封装， Google 这明显是在帮倒忙，还好这忙虽然帮倒了，不过还不至于无法挽回。</p><p>如果大家在使用 RecycleView 还想使用本文提供的方法的话，可以参考我下面的方式实现。提供一个 RecyclerView.ViewHolder 默认实现类，该类提供一个通过 <code>id</code> 获取视图的方法，在创建 Item 的 View 的时候默认都返回这个类的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class MyViewHolder(val convertView: View) : RecyclerView.ViewHolder(convertView) &#123;</div><div class="line">    fun &lt;T : View&gt; findView(viewId: Int): T &#123;</div><div class="line">        return convertView.findViewOften(viewId)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果不想 <code>MyViewHolder</code> 的外部有不需要的依赖，可以将 <code>findViewOften</code> 直接实现在 <code>MyViewHolder</code> 里面。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="noopener">ViewHolder</a></li><li><a href="http://www.programcreek.com/java-api-examples/android.util.SparseArray" target="_blank" rel="noopener">Java Code Examples for android.util.SparseArray</a></li><li><a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="noopener">AndroidExtension</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tags: Android, Kotlin&lt;/p&gt;
&lt;h2 id=&quot;ViewHolder&quot;&gt;&lt;a href=&quot;#ViewHolder&quot; class=&quot;headerlink&quot; title=&quot;ViewHolder&quot;&gt;&lt;/a&gt;ViewHolder&lt;/h2&gt;&lt;p&gt;作为一名 Andr
      
    
    </summary>
    
    
      <category term="Android" scheme="http://ohmerhe.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>NullPointException 利器 Kotlin 可选型</title>
    <link href="http://ohmerhe.com/2016/07/14/kotlin-type-option/"/>
    <id>http://ohmerhe.com/2016/07/14/kotlin-type-option/</id>
    <published>2016-07-14T10:52:57.000Z</published>
    <updated>2019-01-02T02:38:31.101Z</updated>
    
    <content type="html"><![CDATA[<p>tags: Kotlin</p><p>NullPointException (简称 NPE ) 被称作 <a href="https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions" target="_blank" rel="noopener">The Billion Dollar Mistake</a> 一直困扰着Java 和 Android 开发者。Kotlin 的类型系统中提供可选类型用于减少 NPE 问题带来的风险。</p><a id="more"></a><p>虽然，Kotlin 提供了可选类型用于减少 NPE 问题的风险，但是并没有办法完全消除 NPE 带来的隐患，本问将探讨如何巧妙地使用「可选型」更好的规避 NPE 的发生。</p><h2 id="可选型定义"><a href="#可选型定义" class="headerlink" title="可选型定义"></a>可选型定义</h2><h3 id="非空类型"><a href="#非空类型" class="headerlink" title="非空类型"></a>非空类型</h3><p>我们先从可选型的定义开始，当我们在 Kotlin 中定义一个变量时，默认就是非空类型的，当你将一个非空类型置空的时候，编译器会告诉你这不可行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a: String = <span class="string">"abc"</span></div><div class="line">a = <span class="literal">null</span> <span class="comment">// compilation error</span></div></pre></td></tr></table></figure><p>因此，如果你后面任何时候使用该变量时，都可以放心的使用而不用担心会发生 NPE。所以要想远离 NPE，首先需要<strong>「尽可能的使用非空类型的定义」</strong>。</p><h3 id="可选型（可空类型）"><a href="#可选型（可空类型）" class="headerlink" title="可选型（可空类型）"></a>可选型（可空类型）</h3><p>虽然「非空类型」能够有效避免 NPE 的问题，但是有时候我们总不可避免的需要使用「可选类型」。在定义可选型的时候，我们只要在非空类型的后面添加一个 <code>?</code> 就可以了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b: String? = <span class="string">"abc"</span></div><div class="line">b = <span class="literal">null</span> <span class="comment">// ok</span></div></pre></td></tr></table></figure><p>在使用可选型变量的时候，这个变量就有可能为空，所以在使用前我们应该对其进行空判断（在 Java 中我们经常这样做），这样往往带来带来大量的工作，这些空判断代码本身没有什么实际意义，并且让代码的可读性和简洁性带来了巨大的挑战。在网上可以看到许多人针对如何减少 NPE 提出了自己的建议，有的的确很不错，但成本依然很大。除此之外，还有一个最可恶的场景「我们会忘记」。</p><p>Kotlin 为了解决这个问题，它并不允许我们直接使用一个可选型的变量去调用方法或者属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b.length <span class="comment">// compilation error</span></div></pre></td></tr></table></figure><p>你可以和 Java 中一样，在使用变量之前先进行空判断，然后再去调用。如果使用这种方法，那么空判断是必须的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> <span class="number">-1</span></div></pre></td></tr></table></figure><p><strong>注意： 如果你定义的变量是全局变量，即使你做了空判断，依然不能使用变量去调用方法或者属性。</strong>这个时候你需要考虑使用下面的介绍的方法。</p><p>Kotlin 为可选型提供了一个安全调用操作符 <code>?.</code>，使用该操作符可以方便调用可选型的方法或者属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b?.length</div></pre></td></tr></table></figure><p>这里 <code>l</code> 得到的返回依然是一个可选型 <code>Int?</code>。</p><p>Kotlin 还提供了一个强转的操作符 <code>!!</code>，这个操作符能够强行调用变量的方法或者属性，而不管这个变量是否为空，如果这个时候该变量为空时，那么就会发生 NPE。所以如果不想继续陷入 NPE 的困境无法自拔，请不要该操作符走的太近。</p><h2 id="Elvis-操作符"><a href="#Elvis-操作符" class="headerlink" title="Elvis 操作符"></a><code>Elvis</code> 操作符</h2><p>上面有提到一种情况，当 <code>b</code> 为空时，返回它的长度值给一个默认值 -1。要实现这样的逻辑当然可以用 <code>ifelse</code> 的逻辑判断实现，但 Kotlin 提供了一个更优雅的书写方式 <code>?:</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> l = b?.length ?: <span class="number">-1</span></div></pre></td></tr></table></figure><p><code>b?.length ?: -1</code> 和 <code>if (b != null) b.length else -1</code> 完全等价的。</p><p>其实你还可以在 <code>?:</code> 后面添加任何表达式，比如你可以在后面会用 <code>return</code> 和 <code>throw</code>（在 Kotlin 中它们都是表达式）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(node: <span class="type">Node</span>)</span></span>: String? &#123;</div><div class="line">  <span class="keyword">val</span> parent = node.getParent() ?: <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">  <span class="keyword">val</span> name = node.getName() ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"name expected"</span>)</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="let-函数"><a href="#let-函数" class="headerlink" title="let 函数"></a><code>let</code> 函数</h2><p><code>let</code> 是官方 <code>stdlib</code> 提供的标准函数库里面的函数，这个函数巧妙的利用的 Kotlin 语言的特性让 <code>let</code> 接受的表达式参数中的调用方是非空的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> listWithNulls: List&lt;String?&gt; = listOf(<span class="string">"A"</span>, <span class="literal">null</span>)</div><div class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> listWithNulls) &#123;</div><div class="line">    item?.let &#123; println(it) &#125; <span class="comment">// prints A and ignores null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码的只会输出 <code>A</code>，而不会输出 <code>null</code>。</p><p><strong>需要注意的是，这个方法调用的时候必须要使用 <code>?.</code> 操作符调用才能生效哦。</strong>如果你的部分代码依赖于一个可选型变量为非空的时候，就可以使用 <code>let</code> 函数。</p><p>参考这个函数的实现，下面我尝试提供几个自己定义的方法。</p><h2 id="自定义处理"><a href="#自定义处理" class="headerlink" title="自定义处理"></a>自定义处理</h2><p>这里定义的两个方法是参考 <code>Swift</code> 里面的 <code>if let</code> 和 <code>guard</code> 进行的抽象。</p><h3 id="orElse-函数"><a href="#orElse-函数" class="headerlink" title="orElse 函数"></a><code>orElse</code> 函数</h3><p><code>orElse</code> 是和 <code>Elvis</code> 函数结合使用的，默认 <code>Elvis</code> 后面只能直接或者执行一个表达式获取返回值或者直接通过 <code>return</code> 或者 <code>throw</code> 结束当前函数的执行。结合 <code>orElse</code> 函数，你能够更加灵活的处理前面的 <code>null</code>。</p><ul><li>你可以处理一些逻辑以后，再返回一个可用的值。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a:String? = <span class="literal">null</span></div><div class="line"><span class="keyword">var</span> b = a ?: orElse &#123;</div><div class="line"><span class="comment">// 做任何事</span></div><div class="line">   <span class="keyword">return</span><span class="symbol">@orElse</span> <span class="string">"s"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>也可以处理一些逻辑后， 通过<code>return</code> 或者 <code>throw</code> 结束当前函数的执行。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a:String? = <span class="literal">null</span></div><div class="line"><span class="keyword">var</span> b = a ?: orElse &#123;</div><div class="line"><span class="comment">// 做任何事</span></div><div class="line">   <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="guard-函数"><a href="#guard-函数" class="headerlink" title="guard 函数"></a><code>guard</code> 函数</h3><p><code>Elvis</code> 默认只能对单个变量或表达式是否为空进行处理，当碰到多个变量需要一起判断时，就会束手无策，<code>guard</code> 就是为了解决这个问题。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">fun testGuard(a: String?, b: String?, c: String?)&#123;</div><div class="line">guard(a, b, c) ?: orElse &#123;</div><div class="line">        print("a or b or c is null </div><div class="line">")</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    // 现在 `a`，`b`，`c` 都是不为空</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于没有编译器的支持，所以暂时还不能实现 <a href="https://kotlinlang.org/docs/reference/null-safety.html#checking-for-null-keyword--in-conditions" target="_blank" rel="noopener">空屏蔽</a>。</p><p>这里定义的两个函数的实现，你可以自己尝试去实现一下，就当是个练习（鬼笑）。<a href="https://github.com/KotlinThree/AndroidExtension" target="_blank" rel="noopener">AndroidExtension</a>有具体的实现代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过一系列分析以后，我们已经对怎么使用好 Kotlin 可选型有一定的了解，如果不想 NPE 问题不断困扰，可以参考这里总结的几条。</p><ul><li>尽可能的使用非空类型的定义</li><li>远离 <code>!!</code>，如果非要用，请调用代码在前面「三行之内」进行非空判断</li><li>熟练使用 <code>Elvis</code> 操作符</li><li>自定义一些常用的函数，让自己的代码更流畅</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://kotlinlang.org/docs/reference/null-safety.html" target="_blank" rel="noopener">null-safety</a></li><li><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0056-trailing-closures-in-guard.md" target="_blank" rel="noopener">trailing-closures-in-guard</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: Kotlin&lt;/p&gt;
&lt;p&gt;NullPointException (简称 NPE ) 被称作 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Billion Dollar Mistake&lt;/a&gt; 一直困扰着Java 和 Android 开发者。Kotlin 的类型系统中提供可选类型用于减少 NPE 问题带来的风险。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 函数式编程三板斧</title>
    <link href="http://ohmerhe.com/2016/07/05/kotlin_function_three_common_methods/"/>
    <id>http://ohmerhe.com/2016/07/05/kotlin_function_three_common_methods/</id>
    <published>2016-07-05T14:06:41.000Z</published>
    <updated>2019-01-02T02:38:31.192Z</updated>
    
    <content type="html"><![CDATA[<p>tags: kotlin, 函数式编程, map, filter, reduce</p><p>每个函数式语言都提供及几大类基本函数，这些函数在功能上一般都极为相似，但是在名称和调用方法上可能有一些细微的差别。今天就讲讲 <code>Kotlin</code> 中提供的函数式编程三板斧<code>filter</code>、<code>map</code>、<code>reduce</code>。</p><a id="more"></a><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>筛选函数将用户给定的布尔逻辑作用于集合，返回由原集合中符合条件的元素组合的一个子集。假设一个逻辑，将数组中是3的倍数的数筛选出来，和 <code>Java</code> 做一个简单的对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java 代码</span></div><div class="line"><span class="keyword">int</span>[] all = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</div><div class="line">List&lt;Integer&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : all) &#123;</div><div class="line">    <span class="keyword">if</span> (a % <span class="number">3</span> == <span class="number">0</span>) &#123;</div><div class="line">        filters.add(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> all = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</div><div class="line"><span class="keyword">val</span> filters = all.filter &#123; it % <span class="number">3</span> == <span class="number">0</span> &#125;</div></pre></td></tr></table></figure><p>Kotlin 还提供一系列类似的过滤函数：</p><ul><li><code>filterIndexed</code>, 同 <code>filter</code>，不过在逻辑判断的方法块中可以拿到当前item的index</li><li><code>filterNot</code>，与<code>filter</code>相反，只返回不符合条件的元素组合</li></ul><p>针对 <code>Map</code> 类型数据集合，提供了 <code>filterKeys</code> 和 <code>filterValues</code> 方法，方便只做 key 或者 value 的判断。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>映射函数也是一个高阶函数，将一个集合经过一个传入的变换函数映射成另外一种集合。</p><p>假设我们现在需要将一系列的名字的长度保存到另一个数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 代码</span></div><div class="line">String[] names = &#123;<span class="string">"James"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Kobe"</span>&#125;;</div><div class="line"><span class="keyword">int</span>[] namesLength = <span class="keyword">new</span> <span class="keyword">int</span>[names.length];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length ; i ++) &#123;</div><div class="line">    namesLength[i] = names[i].length();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> names = arrayOf(<span class="string">"James"</span>, <span class="string">"Tom"</span>, <span class="string">"Jack"</span>, <span class="string">"Kobe"</span>);</div><div class="line"><span class="keyword">val</span> namesLength = names.map &#123; it.length &#125;</div></pre></td></tr></table></figure><p>映射函数是将一个集合映射成另外一种集合，所以当你需要见一个 HaspMap 映射成一个 List 的时候，会非常方便。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> params = mapOf(<span class="string">"limit"</span> to <span class="string">"10"</span>, <span class="string">"offset"</span> to <span class="string">"20"</span>, <span class="string">"order"</span> to <span class="string">"asc"</span>)</div><div class="line"><span class="keyword">val</span> s = params.map &#123; <span class="string">"<span class="subst">$&#123;it.key&#125;</span>=<span class="subst">$&#123;it.value&#125;</span>"</span> &#125;.joinToString(<span class="string">"&amp;"</span>)</div><div class="line"><span class="comment">// s = limit=10&amp;offset=20&amp;order=asc</span></div></pre></td></tr></table></figure><p>同 <code>filter</code> 相似，Kotlin 也提供的 <code>mapIndexed</code> 的类似方法方便使用，针对 <code>Map</code> 类型的集合也有 <code>mapKeys</code> 和 <code>mapValues</code> 的封装。</p><h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>归纳函数将一个数据集合的所有元素通过传入的操作函数实现数据集合的积累叠加效果。</p><p>假设我们需要将一首藏头诗的每句诗的第一句拿出来拼成一句话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 代码</span></div><div class="line">String[] texts = &#123;<span class="string">"芦花丛中一扁舟"</span>, <span class="string">"俊杰俄从此地游"</span>, <span class="string">"义士若能知此理"</span>, <span class="string">"反躬难逃可无忧"</span>&#125;;</div><div class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; texts.length ; i ++) &#123;</div><div class="line">    sb.append(texts[i].substring(<span class="number">0</span>, <span class="number">1</span>));</div><div class="line">&#125;</div><div class="line">String result = sb.toString();</div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Kotlin 代码</span></div><div class="line"><span class="keyword">val</span> texts = arrayOf(<span class="string">"芦花丛中一扁舟"</span>, <span class="string">"俊杰俄从此地游"</span>, <span class="string">"义士若能知此理"</span>, <span class="string">"反躬难逃可无忧"</span>)</div><div class="line"><span class="keyword">val</span> result = texts.map &#123; it.substring(<span class="number">0</span>,<span class="number">1</span>) &#125;.reduce &#123; r, s -&gt; <span class="string">"<span class="variable">$r</span><span class="variable">$s</span>"</span>&#125;</div></pre></td></tr></table></figure><p>最后得到的结果是「卢俊义反」。</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程的精髓在于函数本身。在函数式编程中函数是第一等公民，与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p><p>函数式编程好的实践在于对运算过程的高度抽象和没有”副作用”（既保持函数的独立性），函数式编程三板斧是函数式编程的典型范式，在编程中被大量使用，即使人们不关注函数式编程，在使用函数式编程语言的时候，也会不自觉的使用这些函数。</p><p>函数式编程是一种思维方式，函数式编程鼓励放弃对状态的维持（是命令式编程的基础），将所有的操作都交给运行时去执行。当然为了保证程序运行的效率，这需要提供一些辅助性的手段（缓存、缓求值等）。</p><p>[参考资料]</p><ul><li><a href="https://book.douban.com/subject/26587213/" target="_blank" rel="noopener">函数式编程思维</a></li><li><a href="http://baike.baidu.com/view/1711147.htm" target="_blank" rel="noopener">函数式编程</a></li><li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">kotlin doc</a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/" target="_blank" rel="noopener">kotlin api doc</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: kotlin, 函数式编程, map, filter, reduce&lt;/p&gt;
&lt;p&gt;每个函数式语言都提供及几大类基本函数，这些函数在功能上一般都极为相似，但是在名称和调用方法上可能有一些细微的差别。今天就讲讲 &lt;code&gt;Kotlin&lt;/code&gt; 中提供的函数式编程三板斧&lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;reduce&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
      <category term="函数式编程" scheme="http://ohmerhe.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>LoopBack 操作记录</title>
    <link href="http://ohmerhe.com/2016/06/26/loopback_useage_record/"/>
    <id>http://ohmerhe.com/2016/06/26/loopback_useage_record/</id>
    <published>2016-06-26T11:02:04.000Z</published>
    <updated>2019-01-02T02:38:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>tags: LoopBack, MySQL</p><h2 id="什么是LoopBack"><a href="#什么是LoopBack" class="headerlink" title="什么是LoopBack"></a>什么是LoopBack</h2><p>请看<a href="https://loopback.io/" target="_blank" rel="noopener">官方文档</a></p><a id="more"></a><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>继续查看<a href="http://loopback.io/getting-started/" target="_blank" rel="noopener">Getting started</a></p><h2 id="自定义MySql连接"><a href="#自定义MySql连接" class="headerlink" title="自定义MySql连接"></a>自定义MySql连接</h2><h3 id="自定义table名字"><a href="#自定义table名字" class="headerlink" title="自定义table名字"></a>自定义table名字</h3><p>在模型的json文件中<code>common/model/category.json</code>添加Mysql的配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "name": "Category",</div><div class="line">  ...</div><div class="line">  "mysql": &#123;</div><div class="line">    "table": "custom_category" // 自定义的表名</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更多Model的Json定义参考<a href="https://docs.strongloop.com/display/public/LB/Model+definition+JSON+file" target="_blank" rel="noopener">Model definition JSON file</a></p><h3 id="自定义table列名"><a href="#自定义table列名" class="headerlink" title="自定义table列名"></a>自定义table列名</h3><p>同样在模型定义的json文件中，<code>common/model/category.json</code>找到<code>properties</code>模块的配置，为需要自定义表列名的属性下添加<code>msql</code>配置信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "name": "category",</div><div class="line">  ...</div><div class="line">  "properties": &#123;</div><div class="line">    ...</div><div class="line">    "title": &#123;</div><div class="line">      "type": "String",</div><div class="line">      "required": true,</div><div class="line">      "mysql":&#123;</div><div class="line">        "columnName":"question_content",</div><div class="line">        "dataType":"VARCHAR"</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有其他类型类型的对应关系，可以看<a href="https://docs.strongloop.com/display/public/LB/MySQL+connector" target="_blank" rel="noopener">MySQL connector</a></p><h2 id="自定义请求方法-Remote-Method"><a href="#自定义请求方法-Remote-Method" class="headerlink" title="自定义请求方法(Remote Method)"></a>自定义请求方法(Remote Method)</h2><p>loopback默认提供了许多方法，可以方便的访问到服务端的资源，这里列出一些常用的，更多的方法可以参考<a href="http://apidocs.strongloop.com/loopback/#persistedmodel" target="_blank" rel="noopener">文档</a>。</p><table><thead><tr><th>method</th><th>path</th><th>verb</th></tr></thead><tbody><tr><td>find</td><td>/</td><td>GET</td></tr><tr><td>findById</td><td>/:id</td><td>GET</td></tr><tr><td>findOne</td><td>/findOne</td><td>GET</td></tr><tr><td>deleteById</td><td>/:id</td><td>DELETE</td></tr><tr><td>count</td><td>/count</td><td>GET</td></tr><tr><td>exists</td><td>/:id/exists</td><td>GET</td></tr><tr><td>exists</td><td>/:id</td><td>HEAD</td></tr><tr><td>create</td><td>/</td><td>POST</td></tr><tr><td>upsert</td><td>/</td><td>PUT</td></tr><tr><td>exists</td><td>/exists</td><td>GET</td></tr><tr><td>exists</td><td>/exists</td><td>GET</td></tr></tbody></table><p>这些方法的定义和注册都可以在<code>/node_modules/loopback/lib/persisted-model.js</code>文件中看到。如<code>find</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">PersistedModel.find = <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">filter, cb</span>) </span>&#123;</div><div class="line">  throwNotAttached(<span class="keyword">this</span>.modelName, <span class="string">'find'</span>);</div><div class="line">&#125;;</div><div class="line">setRemoting(PersistedModel, <span class="string">'find'</span>, &#123;</div><div class="line">  <span class="attr">description</span>: <span class="string">'Find all instances of the model matched by filter from the data source.'</span>,</div><div class="line">  <span class="attr">accessType</span>: <span class="string">'READ'</span>,</div><div class="line">  <span class="attr">accepts</span>: &#123;<span class="attr">arg</span>: <span class="string">'filter'</span>, <span class="attr">type</span>: <span class="string">'object'</span>, <span class="attr">description</span>: <span class="string">'Filter defining fields, where, include, order, offset, and limit'</span>&#125;,</div><div class="line">  <span class="attr">returns</span>: &#123;<span class="attr">arg</span>: <span class="string">'data'</span>, <span class="attr">type</span>: [typeName], <span class="attr">root</span>: <span class="literal">true</span>&#125;,</div><div class="line">  <span class="attr">http</span>: &#123;<span class="attr">verb</span>: <span class="string">'get'</span>, <span class="attr">path</span>: <span class="string">'/'</span>&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>参照上面的方法我们可以自定义一些需要的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">Person</span>)</span>&#123;</div><div class="line">    Person.greet = <span class="function"><span class="keyword">function</span>(<span class="params">msg, cb</span>) </span>&#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="string">'Greetings... '</span> + msg);</div><div class="line">    &#125;</div><div class="line">    Person.remoteMethod(</div><div class="line">        <span class="string">'greet'</span>, </div><div class="line">        &#123;</div><div class="line">          <span class="attr">accepts</span>: &#123;<span class="attr">arg</span>: <span class="string">'msg'</span>, <span class="attr">type</span>: <span class="string">'string'</span>&#125;,</div><div class="line">          <span class="attr">http</span>: &#123;<span class="attr">verb</span>: <span class="string">'get'</span>, <span class="attr">path</span>: <span class="string">'/greet'</span>&#125;,</div><div class="line">          <span class="attr">returns</span>: &#123;<span class="attr">arg</span>: <span class="string">'greeting'</span>, <span class="attr">type</span>: <span class="string">'string'</span>&#125;</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我们可以通过<code>GET /api/persons/greet?msg=John</code>获得如下的返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Greetings... John</div></pre></td></tr></table></figure><p>关于自定义方法的参数说明可以参考<a href="https://docs.strongloop.com/display/public/LB/Remote+methods" target="_blank" rel="noopener">详细描述</a></p><h2 id="自定义返回数据"><a href="#自定义返回数据" class="headerlink" title="自定义返回数据"></a>自定义返回数据</h2><p>loopback提供了一系列方法可以改变资源返回，比如我需要将请求到的资源列表包装在一个对象的<code>list</code>下返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Category.afterRemote(<span class="string">'find'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ctx, remoteMethodOutput, next</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ctx.result &amp;&amp; <span class="built_in">Array</span>.isArray(remoteMethodOutput)) &#123;</div><div class="line">      ctx.result = &#123;</div><div class="line">        <span class="string">"list"</span>: remoteMethodOutput</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    next();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">自定义返回结果前</div><div class="line">[</div><div class="line">&#123;...&#125;,</div><div class="line">&#123;...&#125;,</div><div class="line">&#123;...&#125;,</div><div class="line">&#123;...&#125;</div><div class="line">]</div><div class="line">自定义返回结果后</div><div class="line">&#123;</div><div class="line">"list" : [</div><div class="line">&#123;...&#125;,</div><div class="line">&#123;...&#125;,</div><div class="line">&#123;...&#125;,</div><div class="line">&#123;...&#125;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>更多关于请求资源的逻辑控制，请参考<a href="https://docs.strongloop.com/display/public/LB/Adding+logic+to+models" target="_blank" rel="noopener">Adding logic to models</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tags: LoopBack, MySQL&lt;/p&gt;
&lt;h2 id=&quot;什么是LoopBack&quot;&gt;&lt;a href=&quot;#什么是LoopBack&quot; class=&quot;headerlink&quot; title=&quot;什么是LoopBack&quot;&gt;&lt;/a&gt;什么是LoopBack&lt;/h2&gt;&lt;p&gt;请看&lt;a href=&quot;https://loopback.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://ohmerhe.com/tags/MySQL/"/>
    
      <category term="LoopBack" scheme="http://ohmerhe.com/tags/LoopBack/"/>
    
  </entry>
  
  <entry>
    <title>树莓派安装 Node</title>
    <link href="http://ohmerhe.com/2016/06/26/raspberry_install_node/"/>
    <id>http://ohmerhe.com/2016/06/26/raspberry_install_node/</id>
    <published>2016-06-26T08:23:04.000Z</published>
    <updated>2019-01-02T02:38:31.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><h3 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h3><p>国外有个哥们为树莓派的Node.js制作了一个安装包，可以非常方便的安装，但是有一个缺点是版本不是最新。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget http://node-arm.herokuapp.com/node_latest_armhf.deb </div><div class="line">sudo dpkg -i node_latest_armhf.deb</div></pre></td></tr></table></figure><h3 id="官方渠道安装"><a href="#官方渠道安装" class="headerlink" title="官方渠道安装"></a>官方渠道安装</h3><p>官方有两个版本可以选择，LTS版和Current版，选择官方推荐LTS版。然后该选择那个平台的包呢。</p><p>运行查看本机的CPU信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo</div></pre></td></tr></table></figure><p>可以得到类似下面的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">processor: 0</div><div class="line">model name: ARMv7 Processor rev 5 (v7l)</div><div class="line">BogoMIPS: 38.40</div><div class="line">Features: half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm</div><div class="line">CPU implementer: 0x41</div><div class="line">CPU architecture: 7</div><div class="line">CPU variant: 0x0</div><div class="line">CPU part: 0xc07</div><div class="line">CPU revision: 5</div><div class="line"></div><div class="line">processor: 1</div><div class="line">model name: ARMv7 Processor rev 5 (v7l)</div><div class="line">BogoMIPS: 38.40</div><div class="line">Features: half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm</div><div class="line">CPU implementer: 0x41</div><div class="line">CPU architecture: 7</div><div class="line">CPU variant: 0x0</div><div class="line">CPU part: 0xc07</div><div class="line">CPU revision: 5</div><div class="line">...</div></pre></td></tr></table></figure><p>根据输出可以确定我们该选择<code>armv7</code>的包。下载相应的包(当前LTS版最新为4.4.5)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://nodejs.org/dist/v4.4.5/node-v4.4.5-linux-armv7l.tar.gz</div></pre></td></tr></table></figure><p>下载完成后直接将包解压到对应的目录，并且重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo tar -xzf node-v4.4.5-linux-armv7l.tar.gz -C /usr/<span class="built_in">local</span>/</div><div class="line">mv /usr/<span class="built_in">local</span>/node-v4.4.5-linux-armv7l /usr/<span class="built_in">local</span>/node</div></pre></td></tr></table></figure><p>PS： 如果你下载的是老版本的话，可能需要自行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure><p>添加到系统路径中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim ~/.bashrc</div></pre></td></tr></table></figure><p>在最后一行加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/node/bin</div></pre></td></tr></table></figure><p>保存以后运行<code>source ~/.bashrc</code>更新命令行</p><h3 id="检测安装"><a href="#检测安装" class="headerlink" title="检测安装"></a>检测安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pi@raspberrypi:~ $ node -v</div><div class="line">v4.4.5</div><div class="line">pi@raspberrypi:~ $ npm -v</div><div class="line">2.15.5</div></pre></td></tr></table></figure><h2 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</div></pre></td></tr></table></figure><h2 id="安装LoopBack"><a href="#安装LoopBack" class="headerlink" title="安装LoopBack"></a>安装LoopBack</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install -g strongloop</div></pre></td></tr></table></figure><p>安装失败，原因不明，试试<code>npm</code>，安装成功。（对于cnpm和npm的差别不是很了解，不过自己平时在安装的时候可以先用<code>cnpm</code>安装，不行的话再尝试<code>npm</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g strongloop</div></pre></td></tr></table></figure><p>安装以后，就可以根据官方提供的<a href="http://loopback.io/getting-started/" target="_blank" rel="noopener">文档</a>创建Hello World</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://node-arm.herokuapp.com/" target="_blank" rel="noopener">http://node-arm.herokuapp.com/</a></li><li><a href="http://joshondesign.com/2013/10/23/noderpi" target="_blank" rel="noopener">Install Node on the Raspberry Pi in 5 minutes</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></li><li><a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝 NPM 镜像</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装Node&quot;&gt;&lt;a href=&quot;#安装Node&quot; class=&quot;headerlink&quot; title=&quot;安装Node&quot;&gt;&lt;/a&gt;安装Node&lt;/h2&gt;&lt;h3 id=&quot;快速安装&quot;&gt;&lt;a href=&quot;#快速安装&quot; class=&quot;headerlink&quot; title=&quot;快速安装&quot;&gt;&lt;/a&gt;快速安装&lt;/h3&gt;&lt;p&gt;国外有个哥们为树莓派的Node.js制作了一个安装包，可以非常方便的安装，但是有一个缺点是版本不是最新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="http://ohmerhe.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="Node.js" scheme="http://ohmerhe.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>用 U 盘为树莓派备份镜像</title>
    <link href="http://ohmerhe.com/2016/06/25/raspberry_backup_system_img/"/>
    <id>http://ohmerhe.com/2016/06/25/raspberry_backup_system_img/</id>
    <published>2016-06-25T13:02:22.000Z</published>
    <updated>2019-01-02T02:38:31.355Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派使用了一段时间以后，已经为树莓派装了好多东西，也做了好多配置。有必要为系统做一次备份，就不用每次都重头开始了。</p><a id="more"></a><p>准备工作：</p><ul><li>空白U盘（最好是8G以上，也可以是sd卡+读卡器）</li><li>可以上网的树莓派</li></ul><h2 id="下载脚本"><a href="#下载脚本" class="headerlink" title="下载脚本"></a>下载脚本</h2><p>进入树莓派系统，下载脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://raw.githubusercontent.com/billw2/rpi-clone/master/rpi-clone</div></pre></td></tr></table></figure><p>为脚本设置执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod +x rpi-clone</div></pre></td></tr></table></figure><h2 id="U盘准备"><a href="#U盘准备" class="headerlink" title="U盘准备"></a>U盘准备</h2><p>在插入u盘前，先运行<code>sudo fdisk -l</code>查看树莓派的磁盘。SD卡插槽上正在运行系统的SD卡应该显示为/dev/mmcblk0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Device         Boot  Start      End  Sectors  Size Id Type</div><div class="line">/dev/mmcblk0p1        8192   137215   129024   63M  c W95 FAT32 (LBA)</div><div class="line">/dev/mmcblk0p2      137216 31116287 30979072 14.8G 83 Linux</div></pre></td></tr></table></figure><p>插入U盘，再运行上面的命令，可以看到增加了下面的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Device     Boot Start      End  Sectors  Size Id Type</div><div class="line">/dev/sda1  *       64 15771647 15771584  7.5G  b W95 FAT32</div></pre></td></tr></table></figure><p>/dev/sda1（或者是/dev/sdb1）就是我们插入的空白U盘。</p><h2 id="备份镜像"><a href="#备份镜像" class="headerlink" title="备份镜像"></a>备份镜像</h2><p>运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./rpi-clone sda -f</div></pre></td></tr></table></figure><p>这里，第一个参数是SD卡的名字，这里是<code>sda</code>。<code>-f</code>告诉脚本完整格式化SD卡。</p><p>脚本会提示你是否初始化目标SD卡。输入<code>yes</code>然后按一下回车。</p><p><img src="http://images.notend.cn/image/raspberry_backup_1.png" alt=""></p><p>接着，会提示你是否想给你的备份镜像指定一个标签，你可以设置一个标签，或者直接回车跳过。</p><p><img src="http://images.notend.cn/image/raspberry_backup_2.png" alt=""></p><p>最后，会有一次最终确认，输入<code>yes</code>回车，等待一段时间。</p><p><img src="http://images.notend.cn/image/raspberry_backup_3.png" alt=""></p><p>备份完成后，会提示你是否卸载(unmount)这个新系统卡，输入<code>yes</code>回车完成备份。</p><p>到这里整个备份已经完成</p><h2 id="镜像还原"><a href="#镜像还原" class="headerlink" title="镜像还原"></a>镜像还原</h2><p>树莓派本身不支持从U盘启动，所以经过上面的步骤备份好的系统要还原使用，还需要进一步处理。</p><p>一种方式是让你的树莓派支持从U盘启动，具体可以参考<a href="http://www.geekfan.net/5244/" target="_blank" rel="noopener">树莓派支持多系统启动</a>。</p><p>另外就是先将系统还原到sd卡中使用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://shumeipai.nxez.com/2014/06/01/do-system-backup-image-of-raspberry-pi-for-linux-or-mac.html" target="_blank" rel="noopener">为树莓派做系统备份镜像</a></li><li><a href="http://blog.lxx1.com/1450" target="_blank" rel="noopener">制作树苺派SD卡备份镜像——树苺派系统备份与还原指南</a></li><li><a href="http://www.geekfan.net/5244/" target="_blank" rel="noopener">如何使用BerryBoot来使树莓派支持多系统启动</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树莓派使用了一段时间以后，已经为树莓派装了好多东西，也做了好多配置。有必要为系统做一次备份，就不用每次都重头开始了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="http://ohmerhe.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 实现配置化网络请求</title>
    <link href="http://ohmerhe.com/2016/06/13/kotlin_config_http_kolley/"/>
    <id>http://ohmerhe.com/2016/06/13/kotlin_config_http_kolley/</id>
    <published>2016-06-13T12:23:05.000Z</published>
    <updated>2019-01-02T02:38:31.132Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin官方提供一个DSL的典型应用场景，<a href="https://github.com/Kotlin/anko" target="_blank" rel="noopener">Anko</a>致力直接用Kotlin配置页面布局和视图的属性。将布局文件代码化能够带来许多如类型安全、解析效率、代码重用等好处，而<code>Anko</code>让代码布局和XML一样简洁清晰。</p><a id="more"></a><p>受到<code>Anko</code>的启发，让我萌生了把<code>Android</code>中网络请求纷繁复杂配置信息也封装成配置化方式，实现如下方式的网络请求。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Http.<span class="keyword">get</span> &#123;</div><div class="line">    url = <span class="string">"http://api.openweathermap.org/data/2.5/weather"</span></div><div class="line">    headers &#123;</div><div class="line">        <span class="string">"Content-Type"</span> - <span class="string">'application/json'</span></div><div class="line">        <span class="string">"pragma-token"</span> - <span class="string">'33162acxxxxxx5032ad21e0e79ff70d'</span></div><div class="line">    &#125;</div><div class="line">    params &#123;</div><div class="line">        <span class="string">"q"</span> - <span class="string">"shanghai"</span></div><div class="line">        <span class="string">"appid"</span> - <span class="string">"d7a98cf22463b1c0c3df4adfe5abbc77"</span></div><div class="line">    &#125;</div><div class="line">    onSuccess &#123; bytes -&gt;</div><div class="line">        <span class="comment">// handle data</span></div><div class="line">    &#125;</div><div class="line">    onFail &#123; error -&gt;</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>目前该框架已经完成，后面还会继续完善，项目地址<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="noopener">Kolley</a></p><p>奔着这个目标，我把之前自己简单封装的Volley库翻出来，用Kotlin重新封装一下。经过分析总体过程大概如下：</p><ul><li>基础代码转Kotlin</li><li>重定义原子Request</li><li>Request构造配置化</li><li>提供RESTful方法</li></ul><h2 id="基础代码转Kotlin"><a href="#基础代码转Kotlin" class="headerlink" title="基础代码转Kotlin"></a>基础代码转Kotlin</h2><p>之前的框架是参考<a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">android-async-http</a>做的封装，用<code>okhttp</code>作为网络请求引擎，图片请求缓存模块使用的<code>jakewharton</code>提供的<code>disklrucache</code>，这两块都可以复用，先将这部分代码直接转成<code>Kotlin</code>实现。</p><p>这不需要花太多的功夫，将java代码复制过来以后，直接使用Android Studio的快速转换功能，转换后可能会有一些语法上的错误，稍微处理一下就可以了，得到类似的内容。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OkHttpStack</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(client: OkHttpClient = OkHttpClient()) : HurlStack() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mFactory: OkUrlFactory</div><div class="line">    init &#123;</div><div class="line">        mFactory = OkUrlFactory(client)</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Throws(IOException::class)</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createConnection</span><span class="params">(url: <span class="type">URL</span>)</span></span>: HttpURLConnection &#123;</div><div class="line">        <span class="keyword">return</span> mFactory.<span class="keyword">open</span>(url)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="重定义原子Request"><a href="#重定义原子Request" class="headerlink" title="重定义原子Request"></a>重定义原子Request</h2><p>需要在Volley提供的<code>Request</code>基础上继承一个<code>BaseRequest</code>预处理一些信息，如params。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteRequest</span></span>(method: <span class="built_in">Int</span>, url: String, errorListener: Response.ErrorListener? = Response.ErrorListener &#123;&#125;)</div><div class="line">: BaseRequest&lt;ByteArray&gt;(method, url, errorListener) &#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseNetworkResponse</span><span class="params">(response: <span class="type">NetworkResponse</span>?)</span></span>: Response&lt;ByteArray&gt;? &#123;</div><div class="line">        <span class="keyword">return</span> Response.success(response?.<span class="keyword">data</span>, HttpHeaderParser.parseCacheHeaders(response))</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRequest</span>&lt;<span class="type">D</span>&gt;</span>(method: <span class="built_in">Int</span>, url: String, errorListener: Response.ErrorListener? = Response.ErrorListener &#123;&#125;)</div><div class="line">: Request&lt;D&gt;(method, url, errorListener) &#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> DEFAULT_CHARSET = <span class="string">"UTF-8"</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _listener: Response.Listener&lt;D&gt;? = <span class="literal">null</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _params: MutableMap&lt;String, String&gt; = HashMap() <span class="comment">// used for a POST or PUT request.</span></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns a Map of parameters to be used for a POST or PUT request.</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getParams</span><span class="params">()</span></span>: MutableMap&lt;String, String&gt; &#123;</div><div class="line">        <span class="keyword">return</span> _params</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deliverResponse</span><span class="params">(response: <span class="type">D</span>?)</span></span> &#123;</div><div class="line">        _listener?.onResponse(response)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</div><div class="line">            Log.d(<span class="keyword">this</span>.javaClass.simpleName, msg)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Request构造配置化"><a href="#Request构造配置化" class="headerlink" title="Request构造配置化"></a>Request构造配置化</h2><p>上一步封装的<code>Request</code>必须在构造器中提供一些参数，并且像<code>Listener</code>这样的参数不能直接传递表达式，为配置化调用的封装提供了一定的困难。需要重新封装一个<code>Request</code>构造器，再在最后交给执行队列的时候创建真正的<code>Request</code>传递给它，这样让所有网络请求需要的配置信息都可以很方便的构造。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRequestWapper</span></span>() &#123;</div><div class="line">    <span class="keyword">internal</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> _request: ByteRequest</div><div class="line">    <span class="keyword">var</span> url: String = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> method: <span class="built_in">Int</span> = Request.Method.GET</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _start: (() -&gt; <span class="built_in">Unit</span>) = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _success: (ByteArray) -&gt; <span class="built_in">Unit</span> = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _fail: (VolleyError) -&gt; <span class="built_in">Unit</span> = &#123;&#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _finish: (() -&gt; <span class="built_in">Unit</span>) = &#123;&#125;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _params: MutableMap&lt;String, String&gt; = HashMap() <span class="comment">// used for a POST or PUT request.</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> _headers: MutableMap&lt;String, String&gt; = HashMap()</div><div class="line">    <span class="keyword">var</span> tag: Any? = <span class="literal">null</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(onStart: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _start = onStart</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFail</span><span class="params">(onError: (<span class="type">VolleyError</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _fail = onError</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(onSuccess: (<span class="type">ByteArray</span>)</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _success = onSuccess</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onFinish</span><span class="params">(onFinish: ()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        _finish = onFinish</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">params</span><span class="params">(makeParam: <span class="type">RequestPairs</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        <span class="keyword">val</span> requestPair = RequestPairs()</div><div class="line">        requestPair.makeParam()</div><div class="line">        _params.putAll(requestPair.pairs)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">headers</span><span class="params">(makeHeader: <span class="type">RequestPairs</span>.()</span></span> -&gt; <span class="built_in">Unit</span>) &#123;</div><div class="line">        <span class="keyword">val</span> requestPair = RequestPairs()</div><div class="line">        requestPair.makeHeader()</div><div class="line">        _headers.putAll(requestPair.pairs)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">excute</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">var</span> url = url</div><div class="line">        <span class="keyword">if</span> (Request.Method.GET == method) &#123;</div><div class="line">            url = getGetUrl(url, _params) &#123; it.toQueryString() &#125;</div><div class="line">        &#125;</div><div class="line">        _request = ByteRequest(method, url, Response.ErrorListener &#123;</div><div class="line">            _fail(it)</div><div class="line">            _finish()</div><div class="line">        &#125;)</div><div class="line">        _request._listener = Response.Listener &#123;</div><div class="line">            _success(it)</div><div class="line">            _finish()</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (tag != <span class="literal">null</span>) &#123;</div><div class="line">            _request.tag = tag</div><div class="line">        &#125;</div><div class="line">        Http.getRequestQueue().add(_request)</div><div class="line">        _start()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getGetUrl</span><span class="params">(url: <span class="type">String</span>, params: <span class="type">MutableMap</span>&lt;<span class="type">String</span>, String&gt;, toQueryString: (<span class="type">map</span>: <span class="type">Map</span>&lt;<span class="type">String</span>, String&gt;)</span></span> -&gt;</div><div class="line">    String): String &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (params == <span class="literal">null</span> || params.isEmpty()) url <span class="keyword">else</span> <span class="string">"<span class="variable">$url</span>?<span class="subst">$&#123;toQueryString(params)&#125;</span>"</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;K, V&gt;</span>.<span class="title">toQueryString</span><span class="params">()</span></span>: String = <span class="keyword">this</span>.map &#123; <span class="string">"<span class="subst">$&#123;it.key&#125;</span>=<span class="subst">$&#123;it.value&#125;</span>"</span> &#125;.joinToString(<span class="string">"&amp;"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码中将网络请求需要的所有信息全部包装了一层，这样在调用的时候就可以很方便的逐个设置每个参数（当然会有一些默认值），最后在<code>excute()</code>方法中全部设置给真正的<code>Request</code>。这个封装保证了下面的调用方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">url = <span class="string">"http://api.openweathermap.org/data/2.5/weather"</span></div><div class="line">params &#123;</div><div class="line">    <span class="string">"q"</span> - <span class="string">"shanghai"</span></div><div class="line">    <span class="string">"appid"</span> - <span class="string">"d7a98cf22463b1c0c3df4adfe5abbc77"</span></div><div class="line">&#125;</div><div class="line">onSuccess &#123; bytes -&gt;</div><div class="line">    <span class="comment">// handle data</span></div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure><p>PS：上面<code>params</code>是的书写方式，使用了<code>Kotlin</code>的操作符重载功能，具体实现可以下载<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="noopener">源码</a>看下。</p><h2 id="提供RESTful方法"><a href="#提供RESTful方法" class="headerlink" title="提供RESTful方法"></a>提供RESTful方法</h2><p>实现到上一步，已经准备的差不多了，接下来还需要最后一步，提供RESTful请求方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">object</span> Http &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mRequestQueue: RequestQueue? = <span class="literal">null</span></div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</div><div class="line">        <span class="comment">// Set up the network to use OKHttpURLConnection as the HTTP client.</span></div><div class="line">        <span class="comment">// getApplicationContext() is key, it keeps you from leaking the</span></div><div class="line">        <span class="comment">// Activity or BroadcastReceiver if someone passes one in.</span></div><div class="line">        mRequestQueue = Volley.newRequestQueue(context.applicationContext, OkHttpStack(OkHttpClient()))</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRequestQueue</span><span class="params">()</span></span>: RequestQueue &#123;</div><div class="line">        <span class="keyword">return</span> mRequestQueue!!</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> request: (<span class="built_in">Int</span>, BaseRequestWapper.() -&gt; <span class="built_in">Unit</span>) -&gt; Request&lt;ByteArray&gt; = &#123; method, request -&gt;</div><div class="line">        <span class="keyword">val</span> baseRequest = BaseRequestWapper()</div><div class="line">        baseRequest.method = method</div><div class="line">        baseRequest.request()</div><div class="line">        baseRequest.excute()</div><div class="line">        baseRequest._request</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> post = request.partially1(Request.Method.POST)</div><div class="line">    <span class="keyword">val</span> put = request.partially1(Request.Method.PUT)</div><div class="line">    <span class="keyword">val</span> delete = request.partially1(Request.Method.DELETE)</div><div class="line">    <span class="keyword">val</span> head = request.partially1(Request.Method.HEAD)</div><div class="line">    <span class="keyword">val</span> options = request.partially1(Request.Method.OPTIONS)</div><div class="line">    <span class="keyword">val</span> trace = request.partially1(Request.Method.TRACE)</div><div class="line">    <span class="keyword">val</span> patch = request.partially1(Request.Method.PATCH)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的<code>request: (Int, BaseRequestWapper.() -&gt; Unit) -&gt; Request&lt;ByteArray&gt;</code>方法为网络请求提供了入口、保证了配置化代码都可以在<code>{}</code>中调用、完成了真正网络请求添加到执行队列。用户可以通过<code>http.requset(method){}</code>方式发起各种请求。</p><p><code>val get = request.partially1(Request.Method.GET)</code>等提供了RESTful方法的封装，实现<code>Http.get{}</code>的方便调用。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>关于图片请求模块的实现，其实也是异曲同工，虽然更加复杂一点，但是具体思路是一样的。有兴趣的可以下载<a href="https://github.com/ohmerhe/Kolley" target="_blank" rel="noopener">源码</a>查看实现，也欢迎提交代码。</p><p>图片请求的方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Image.display &#123;</div><div class="line">    url = <span class="string">"http://images.notend.cn/android_bg.jpg"</span></div><div class="line">    imageView = mImageView</div><div class="line">    options &#123;</div><div class="line">        <span class="comment">// these values are all default value , you do not need specific them if you do not want to custom</span></div><div class="line">        imageResOnLoading = R.drawable.default_image</div><div class="line">        imageResOnLoading = R.drawable.default_image</div><div class="line">        imageResOnFail = R.drawable.default_image</div><div class="line">        decodeConfig = Bitmap.Config.RGB_565</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        maxWidth = ImageDisplayOption.DETAULT_IMAGE_WIDTH_MAX</div><div class="line">        maxHeight = ImageDisplayOption.DETAULT_IMAGE_HEIGHT_MAX</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Image.load &#123;</div><div class="line">    url = <span class="string">"http://images.notend.cn/android_bg.jpg"</span></div><div class="line">    options &#123;</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        maxWidth = ImageDisplayOption.DETAULT_IMAGE_WIDTH_MAX</div><div class="line">        maxHeight = ImageDisplayOption.DETAULT_IMAGE_HEIGHT_MAX</div><div class="line">    &#125;</div><div class="line">    onSuccess &#123; bitmap -&gt;</div><div class="line">        _imageView2?.setImageBitmap(bitmap)</div><div class="line">    &#125;</div><div class="line">    onFail &#123; error -&gt;</div><div class="line">        log(error.toString())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/Kotlin/anko" target="_blank" rel="noopener">Anko</a></li><li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">Kotlin Refrence</a></li><li><a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="noopener">Volley</a></li><li><a href="http://square.github.io/okhttp" target="_blank" rel="noopener">OKHttp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin官方提供一个DSL的典型应用场景，&lt;a href=&quot;https://github.com/Kotlin/anko&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Anko&lt;/a&gt;致力直接用Kotlin配置页面布局和视图的属性。将布局文件代码化能够带来许多如类型安全、解析效率、代码重用等好处，而&lt;code&gt;Anko&lt;/code&gt;让代码布局和XML一样简洁清晰。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://ohmerhe.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://ohmerhe.com/tags/Kotlin/"/>
    
      <category term="网络请求" scheme="http://ohmerhe.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>树莓派安装 Nginx 和 PHP</title>
    <link href="http://ohmerhe.com/2016/06/10/raspberry_pi_install_php_nginx/"/>
    <id>http://ohmerhe.com/2016/06/10/raspberry_pi_install_php_nginx/</id>
    <published>2016-06-10T12:56:08.000Z</published>
    <updated>2019-01-02T02:38:16.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>先将系统更新到最新状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</div></pre></td></tr></table></figure><a id="more"></a><p>安装Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx -y</div></pre></td></tr></table></figure><p>启动Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/nginx start</div></pre></td></tr></table></figure><p>如果启动成功的话，我们会得到类似的返回</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pi@raspberrypi:~ $ sudo /etc/init.d/nginx start</div><div class="line">[ ok ] Starting nginx (via systemctl): nginx.service.</div></pre></td></tr></table></figure><p>测试远程访问，在浏览器里输入树莓派的ip地址（如果你为你的树莓派配置了域名，也可以通过域名访问），可以看到如下的显示效果：</p><p><img src="http://images.notend.cn/image/nginx_install_success.png" alt="nginx_install_success"></p><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><p>配合Nginx使用时，PHP的安装包和Apache2配合使用稍微有些不同，PHP以FastCGI接口方式运行，因此我们需要安装<code>PHP FPM</code>包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install php5-fpm -y</div></pre></td></tr></table></figure><p>安装完成后会自动启动PHP服务，或者我们可以通过下面的命令启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service php5-fpm start</div></pre></td></tr></table></figure><h2 id="配置Nginx和PHP"><a href="#配置Nginx和PHP" class="headerlink" title="配置Nginx和PHP"></a>配置Nginx和PHP</h2><p>在Nginx和PHP都安装完成以后，我们需要进行一些简单的配置。默认Nginx的配置信息是放在<code>/etc/nginx/sites-available/default</code>中，我们可以将这个默认文件先备份一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mv /etc/nginx/sites-available/default /etc/nginx/sites-available/default.bak</div></pre></td></tr></table></figure><p>然后，然后重新创建一个<code>/etc/nginx/sites-available/default</code>文件，将下面的配置信息添加到该文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/nginx/sites-available/default</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line">    server_name www.myserver.com;</div><div class="line">    root /var/www;</div><div class="line">    index index.html index.htm index.php;</div><div class="line">    access_log /var/log/nginx/myserver.log;</div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">        include snippets/fastcgi-php.conf;</div><div class="line"></div><div class="line">        # With php5-cgi alone:</div><div class="line">        #fastcgi_pass 127.0.0.1:9000;</div><div class="line">        # With php5-fpm:</div><div class="line">        fastcgi_pass unix:/var/run/php5-fpm.sock;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="创建index-php"><a href="#创建index-php" class="headerlink" title="创建index.php"></a>创建index.php</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /var/www/index.php</div></pre></td></tr></table></figure><p>将下面的信息添加到文件中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> phpinfo(); <span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><p>在上面的配置都完成后，重启Nginx服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service nginx restart</div></pre></td></tr></table></figure><p>服务启动后，可以在浏览器访问该服务，看到如下的效果。</p><p><img src="http://images.notend.cn/image/nginx_php_pass.png" alt=""></p><p>PS： 如果在Nginx启动过程中出现问题，可以通过<code>nginx -t</code>查看是什么配置出了问题</p><h3 id="PHP配置"><a href="#PHP配置" class="headerlink" title="PHP配置"></a>PHP配置</h3><p>我们需要编辑<code>/etc/php5/fpm/php.ini</code>（为了安全性）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/php5/fpm/php.ini</div></pre></td></tr></table></figure><p>然后找到<code>cgi.fix_pathinfo=1</code>这一行，并将其改成<code>cgi.fix_pathinfo=0</code>。</p><p>重启PHP服务和Nginx服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service php5-fpm restart</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="[参考资料]"></a>[参考资料]</h2><ul><li><a href="https://www.stewright.me/2014/06/tutorial-install-nginx-and-php-on-raspbian/" target="_blank" rel="noopener">Tutorial – Install Nginx and PHP on Raspbian</a></li><li><a href="https://kevindekoninck.com/raspberry-pi-install-nginx-mysql-php/" target="_blank" rel="noopener">Raspberry Pi – Install nginx, MySQL &amp; PHP</a></li><li><a href="http://workshop.botter.ventures/2013/09/05/how-to-setup-a-web-server-with-nginxphp-on-raspberry-pi/" target="_blank" rel="noopener">How to setup a web server with Nginx/PHP on Raspberry Pi</a></li><li><a href="https://www.digitalocean.com/community/questions/can-t-start-nginx-job-for-nginx-service-failed" target="_blank" rel="noopener">Can’t start Nginx - Job for nginx.service failed</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装Nginx&quot;&gt;&lt;a href=&quot;#安装Nginx&quot; class=&quot;headerlink&quot; title=&quot;安装Nginx&quot;&gt;&lt;/a&gt;安装Nginx&lt;/h2&gt;&lt;p&gt;先将系统更新到最新状态&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="http://ohmerhe.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="NGINX" scheme="http://ohmerhe.com/tags/NGINX/"/>
    
      <category term="PHP" scheme="http://ohmerhe.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>树莓派安装 MySQL</title>
    <link href="http://ohmerhe.com/2016/06/04/raspberry_install_mysql/"/>
    <id>http://ohmerhe.com/2016/06/04/raspberry_install_mysql/</id>
    <published>2016-06-03T16:12:53.000Z</published>
    <updated>2019-01-02T02:38:31.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先将系统更新到最新状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</div></pre></td></tr></table></figure><a id="more"></a><p>然后安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mysql-server</div></pre></td></tr></table></figure><p>接着会提示你为<code>root</code>用户设置密码，并且确认密码。输入完成后，稍等mysql就安装完成。可以测试一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root -p</div></pre></td></tr></table></figure><p>然后输入刚刚设置的密码。</p><h2 id="开启远程登录"><a href="#开启远程登录" class="headerlink" title="开启远程登录"></a>开启远程登录</h2><h3 id="配置权限"><a href="#配置权限" class="headerlink" title="配置权限"></a>配置权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/mysql/my.cnf</div></pre></td></tr></table></figure><p>找到下一行，并且将<code>bind-address</code>的值改成<code>0.0.0.0</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bind</span>-address = 0.0.0.0</div></pre></td></tr></table></figure><p>为root用户开启远程登录权限，并且限制在局域网内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">'root'</span>@<span class="string">'192.168.1.%'</span> IDENTIFIED BY <span class="string">'password'</span> WITH GRANT OPTION;</div></pre></td></tr></table></figure><p>重启MySQL服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/mysql restart</div></pre></td></tr></table></figure><h3 id="打开3306端口"><a href="#打开3306端口" class="headerlink" title="打开3306端口"></a>打开<code>3306</code>端口</h3><p>最后用<code>iptables</code>打开<code>3306</code>端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT -i eth0 -p tcp -m tcp --dport 3306 -j ACCEPT</div></pre></td></tr></table></figure><p>或者限定固定的<code>ip</code>才能访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iptables -A INPUT -i eth0 -s 192.168.1.0/24 -p tcp --destination-port 3306 -j ACCEPT</div></pre></td></tr></table></figure><h3 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> X | telnet -e X 192.168.1.110 3306</div></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc -z -w1 192.168.1.110 3306</div></pre></td></tr></table></figure><p>成功的话，会看到类似的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Connection to 192.168.199.121 port 3306 [tcp/mysql] succeeded!</div></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.stewright.me/2014/06/tutorial-install-mysql-server-on-raspberry-pi/" target="_blank" rel="noopener">Tutorial – Install MySQL server on Raspberry Pi</a></li><li><a href="https://pimylifeup.com/raspberry-pi-mysql-phpmyadmin/" target="_blank" rel="noopener">Raspberry Pi MYSQL &amp; PHPMyAdmin Tutorial</a></li><li><a href="http://www.cyberciti.biz/tips/how-do-i-enable-remote-access-to-mysql-database-server.html" target="_blank" rel="noopener">How Do I Enable Remote Access To MySQL Database Server?</a></li><li><a href="https://www.raspberrypi.org/forums/viewtopic.php?f=36&amp;t=20214" target="_blank" rel="noopener">Remote Access to Mysql on PI</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;先将系统更新到最新状态&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://ohmerhe.com/tags/MySQL/"/>
    
      <category term="树莓派" scheme="http://ohmerhe.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
</feed>
